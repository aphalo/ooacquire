<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>User Guide • ooacquire</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-vignette">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">ooacquire</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right"></ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>User Guide</h1>
            <h3 class="subtitle">
<code>ooacquire</code> 0.1.3.9000</h3>
                        <h4 class="author">Pedro J. Aphalo</h4>
            
            <h4 class="date">2017-05-10</h4>
          </div>

    
    
<div class="contents">
<div id="introduction" class="section level2">
<h2 class="hasAnchor">
<a href="#introduction" class="anchor"></a>Introduction</h2>
<p>In this package we define higher-level functions using packages ‘rOmniDriver’ and the ‘r4photobiology’ suite as bases. These functions conform a sort of “grammar for spectral data acquisition”. We provide a separate function for each conceptual step in the process leading from raw counts to final spectral data—e.g. spectral irradiance. Some higher level functions are included as well, mainly as examples of how to implement some protocols.</p>
<p>The package includes functions for direct data acquisition and near real-time processing of spectra, plus functions that read raw-detector-counts and instrument settings from text files output by the SpectraSuite program from Ocean Optics. After acquisition or file reading the processing of the raw spectral data is identical in both cases.</p>
<p>For data acquisition, the initial steps are opening a connection to an instrument and retrieving a descriptor including model type, optical configuration and possibly calibration data from its non-volatile memory. These first steps in most cases are needed only at the start the R session where data will be acquired. The drivers from Ocean Optics support multichannel instruments and simultaneous connection to multiple spectrometers. This is also supported by this package.</p>
<p>The steps for the acquisition of one raw spectrum are to 1) define the settings to be used, 2) optionally adjust or tune some of these settings automatically, 3) acquire the spectrum, 4) convert the raw counts into linearised counts per second.</p>
<p>In most cases we need acquire more than one raw spectrum, frequently following a certain protocol. There are two possibilities: a) they are conceptually a single observation, such as multiple scans to be averaged to reduce noise or acquired with different integration times (bracketing) and to be merged to increase the dynamic range, and b) sets of spectra in which each spectrum represents a different observation, such as a ‘measurement’ spectrum and a ‘dark’ spectrum to be used to correct it. The distinction may be not that easy to grasp, but in case a) we are measuring a single thing, what we are measuring remains unchanged for all spectra acquired in a set—e.e. we are measuring repeatedly, possibly changing the instrument settings. In case b), although the different spectra may contribute to a single processed spectrum, they are based on measuring a different thing, say a light source and a corresponding dark reading.</p>
<p>In case a) all the acquired raw spectra are stored as columns in the same <code>raw_spct</code> object, while in case b) the different conceptual spectra are each stored in a separate <code>raw_spct</code> object, member of a <code>raw_mspct</code> collection of spectra object. As a) and b) are usually combined, this approach allows and easy distinction of the two situations, and greatly simplifies the coding of later data processing steps.</p>
<p>When spectral data are acquired with other software and read from files into R, this same approach is used for raw data storage. The role of the different files is determined by the structure of a named list used as argument. Files do not contain a full descriptor of the instrument and consequently the instrument descriptor need to be supplied as an additional argument.</p>
<p>Following the approach of the ‘r4photobiology’ suite, we store all available metadata as attributes to the same objects where the acquired spectral data themselves are stored. The stored metadata includes a descriptor of the instrument and the instrument settings used. These attributes are an addition to metadata that is normally held in spectral objects of classes defined in package ‘photobiology’, such as time, location, and label for the measured data. Furthermore, metadata is added at each step, allowing the tracing of the origin and processing of the data. This allows the functions to detect mistakes like an user attempting to linearise raw-counts data that have been already linearised. This safeguard works even for data linearised in the spectrometer software and read from files.</p>
<p>In all cases a wavelength calibration is used to map the pixels to wavelengths. Wavelength calibration can be that retrieved from the instruments’ non-volatile memory or supplied directly by to user. Different further steps are needed depending on the quantity measured and method. In the case of irradiance, a calibration needs to be applied to the counts-per-second spectral data. Usually calibration data is also stored in the non-volatile memory of the spectrometer, but in some cases it is convenient to apply special algorithms or calibration data that cannot be retrieved from the instrument itself. Functions for both the normal and special cases are also included in the package. Here it is important to remember that a calibration will be valid only if the raw spectral data processing steps are exactly the same for the spectral data used for calibration and the measured data. <strong>This in practice means that calibrations supplied by instrument manufacturers will almost never be usable if you process the measured data with this pacakge. You will need the reference lamp spectrum and the raw detector-counts data for the calibration event, to be able to calculate valid calibration coefficients for the best data-processing protocol you adopt for your actual measurements.</strong> On the other hand, this also means that the functions in the present package, as each of them fulfils a simple and well defined step of data processing, are ideal for <em>in silico</em> testing of alternative data processing approaches and measuring protocols.</p>
</div>
<div id="functions" class="section level2">
<h2 class="hasAnchor">
<a href="#functions" class="anchor"></a>Functions</h2>
<table style="width:99%;" class="table">
<colgroup>
<col width="15%">
<col width="83%">
</colgroup>
<thead><tr class="header">
<th align="left">function name</th>
<th align="left">role</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left"><strong>data acquisition</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>start_session</code></td>
<td align="left">search for connected instruments and obtain a handle to the driver</td>
</tr>
<tr class="odd">
<td align="left"><code>end_session</code></td>
<td align="left">close all connections and release handle</td>
</tr>
<tr class="even">
<td align="left"><code>list_instruments</code></td>
<td align="left">list all connected instruments</td>
</tr>
<tr class="odd">
<td align="left"><code>get_oo_descriptor</code></td>
<td align="left">get a descriptor for one of the possibly several connected instruments</td>
</tr>
<tr class="even">
<td align="left"><code>set_descriptor_wl</code></td>
<td align="left">replace the wavelength values</td>
</tr>
<tr class="odd">
<td align="left"><code>set_descriptor_bad_pixs</code></td>
<td align="left">replace the indexes to bad array detector pixels</td>
</tr>
<tr class="even">
<td align="left"><code>set_descriptor_nl</code></td>
<td align="left">replace the function used to correct for array non-linearity</td>
</tr>
<tr class="odd">
<td align="left"><code>set_descriptor_calib_mult</code></td>
<td align="left">replace the vector of irradiance calibration multipliers</td>
</tr>
<tr class="even">
<td align="left"><code>set_descriptor_integ_time</code></td>
<td align="left">replace the vector defining the range of valid integration times</td>
</tr>
<tr class="odd">
<td align="left"><code>get_oo_settings</code></td>
<td align="left">query the instrument to obtain its current settings</td>
</tr>
<tr class="even">
<td align="left"><code>acq_settings</code></td>
<td align="left">build a list of setting values</td>
</tr>
<tr class="odd">
<td align="left"><code>tune_acq_settings</code></td>
<td align="left">tune the integration time and number of scans to the current radiation conditions</td>
</tr>
<tr class="even">
<td align="left"><code>acq_raw_spct</code></td>
<td align="left">take one measurement (data point)</td>
</tr>
<tr class="odd">
<td align="left"><code>acq_raw_mspct</code></td>
<td align="left">take a sequence of spectral measurements (several data points)</td>
</tr>
<tr class="even">
<td align="left"><code>acq_irrad_interactive</code></td>
<td align="left">interactively acquire spectral irradiance and save data and plots to disk</td>
</tr>
<tr class="odd">
<td align="left"><code>acq_trans_interactive</code></td>
<td align="left">interactively acquire spectral transmittance and save data and plots to disk</td>
</tr>
<tr class="even">
<td align="left"><strong>data procesing</strong></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>trim_counts</code></td>
<td align="left">replace values from saturated array pixels with NAs</td>
</tr>
<tr class="even">
<td align="left"><code>bleed_nas</code></td>
<td align="left">replace values from pixels neighbouring NAs with NAs</td>
</tr>
<tr class="odd">
<td align="left"><code>linearize_counts</code></td>
<td align="left">linearize the raw counts</td>
</tr>
<tr class="even">
<td align="left"><code>skip_bad_pixs</code></td>
<td align="left">replace bad pixels with interpolated raw counts</td>
</tr>
<tr class="odd">
<td align="left"><code>ref_correction</code></td>
<td align="left">subtract a reference (e.g. dark signal) from a measured spectrum</td>
</tr>
<tr class="even">
<td align="left"><code>photobiology::fshift</code></td>
<td align="left">can be used to subtract a region of the same scan as an internal “dark” reference</td>
</tr>
<tr class="odd">
<td align="left"><code>raw2cps</code></td>
<td align="left">methods to convert raw counts into counts per second. The method specialization for <code>raw_spct</code> returns a <code>cps_spct</code> object</td>
</tr>
<tr class="even">
<td align="left"><code>merge_cps</code></td>
<td align="left">method to do HDR merge of bracketed scans</td>
</tr>
<tr class="odd">
<td align="left"><code>slit_function_correction</code></td>
<td align="left">apply a correction for the ‘long tails’ of the slit function</td>
</tr>
<tr class="even">
<td align="left"><code>filter_correction</code></td>
<td align="left">apply a correction for stray light based on the use of UV-cut-off or other selective filters</td>
</tr>
<tr class="odd">
<td align="left"><code>no_filter_correction</code></td>
<td align="left">apply a correction for stray light not based on the use of UV-cut-off or other selective filters</td>
</tr>
<tr class="even">
<td align="left"><code>uvb_corrections</code></td>
<td align="left">apply corrections for reducing the impact of stray light and slit function on counts-per-second estimates. This function intelligently adjusts the processing method used based on the spectral data item supplied as <code>x</code> argument</td>
</tr>
<tr class="odd">
<td align="left"><code>which_descriptor</code></td>
<td align="left">select an instrument descriptor from a list based on the dates between which a calibration is valid</td>
</tr>
<tr class="even">
<td align="left"><code>photobiology::cps2irrad</code></td>
<td align="left">methods to convert counts per second into spectral irradiance</td>
</tr>
<tr class="odd">
<td align="left"><code>photobiology::cps2Tfr</code></td>
<td align="left">methods to convert counts per second into transmittance</td>
</tr>
<tr class="even">
<td align="left"><code>photobiology::cps2Rfr</code></td>
<td align="left">methods to convert counts per second into reflectance</td>
</tr>
<tr class="odd">
<td align="left"><strong>calibration</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>compute_irrad_calibration</code></td>
<td align="left">compute irradiance calibration multipliers from raw counts data and polynomial coeffcicientes from standard lamp certificates using any of the different measuring protocols and data processing methods implemented in the package</td>
</tr>
<tr class="odd">
<td align="left"><strong>file reading</strong></td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left"><code>read_oo_ssdata</code></td>
<td align="left">read data from a ‘SpectraSuite’ output file with raw-counts data</td>
</tr>
<tr class="odd">
<td align="left"><code>read_oo_pidata</code></td>
<td align="left">read data from a ‘XXXXXXXXX’ output file with raw-counts data from a Raspberry Pi board</td>
</tr>
<tr class="even">
<td align="left"><code>read_files2mspct</code></td>
<td align="left">read multiple data files and assemble from them into a <code>raw_maspct</code> object compatible to that obtained through direct data acquisition</td>
</tr>
<tr class="odd">
<td align="left"><code>set_oo_ssdata_settings</code></td>
<td align="left">set the instrument settings attributes by decoding the header of text files saved from SpectraSuite</td>
</tr>
<tr class="even">
<td align="left"><code>set_oo_ssdata_descriptor</code></td>
<td align="left">set the instrument descriptor attribute by decoding the header of text files saved from SpectraSuite and optionally merging these data incomplete with a <em>descriptor</em> supplied as argument</td>
</tr>
<tr class="odd">
<td align="left"><code>merge_raw_mspct</code></td>
<td align="left">Merge <code>raw_spct</code> objects members of a single <code>raw_mspct</code> object into a <code>raw_spct</code> object with multiple columns</td>
</tr>
<tr class="even">
<td align="left"><strong>high level method</strong></td>
<td align="left"></td>
</tr>
<tr class="odd">
<td align="left"><code>raw2corr_cps</code></td>
<td align="left">higher level function that returns <strong>corrected</strong> counts per second useful for calculating spectral reflectance and spectral transmittamce.</td>
</tr>
<tr class="even">
<td align="left"><code>s_irrad_corrected</code></td>
<td align="left">high-level method with specializations for files and <code>raw_mspct</code> objects returning spectral irradiance in a <code>source_spct</code> object.</td>
</tr>
</tbody>
</table>
</div>
<div id="workflow" class="section level2">
<h2 class="hasAnchor">
<a href="#workflow" class="anchor"></a>Workflow</h2>
<p>The workflow consists in several steps. First all one needs to start a new connection to the driver by means of <code><a href="../reference/start_session.html">start_session()</a></code> and disconnect at the end of the measuring session with <code><a href="../reference/end_session.html">end_session()</a></code>. To learn which instruments are connected and which numerical index pints to each one uses <code><a href="../reference/list_instruments.html">list_instruments()</a></code>. The indexes start at zero, so if there is only one instrument connected one can rely on its index being 0. The same applies to channels, for multichannel instruments.</p>
<p>Once we know which instrument we want to address and its index, we must create an instrument descriptor with function <code><a href="../reference/get_oo_descriptor.html">get_oo_descriptor()</a></code>. From this point onwards we will use this <em>descriptor</em> to address the instrument. The descriptor contains information about the instrument obtained initially by querying it. Instruments may have some pieces of information unavailable (e.g. not stored in there non-volatile memory), or the user may want to override the available information with that from a more recent or better calibration. <code><a href="../reference/set_descriptor_nl.html">set_descriptor_nl()</a></code>, <code><a href="../reference/set_descriptor_wl.html">set_descriptor_wl()</a></code>, <code><a href="../reference/set_descriptor_bad_pixs.html">set_descriptor_bad_pixs()</a></code> and <code>set_descripto_integ_time()</code> can be used to set or override the function used for correcting for the non-linearity of the sensors, the wavelength values corresponding to each pixel, a vector of indexes (starting at one) corresponding to bad pixels in the array (pixel known to return bad data) and the range of integration times in ms that are valid input for the instrument. __It is always good to check against the specifications of the instrument whether the values stored in its</p>
<p>As there are several settings needed for the acquisition of a spectrum, we will store sets of settings into objects that can reuse and modify. To create these objects we use function <code><a href="../reference/acq_settings.html">acq_settings()</a></code>. The <em>settings</em> include both actual parameters that need to be set in the instrument by sending commands and parameters that our software may use to calculate suitable values for such settings. This function is quite flexible and allows the use of bracketing. In other words a single observation can consist in more than one data acquisition, each of these using different setting, with the aim of merging them into a single spectrum.</p>
<p>Some settings need to be adjusted according to the current irradiance level so as to make full use of the dynamic range of the instrument. For this we use function <code><a href="../reference/acq_settings.html">tune_acq_settings()</a></code>, which updates the settings stored in a list as created by <code><a href="../reference/acq_settings.html">acq_settings()</a></code> or as returned by a previous call to <code><a href="../reference/acq_settings.html">tune_acq_settings()</a></code>.</p>
<p>Function <code><a href="../reference/get_oo_settings.html">get_oo_settings()</a></code> can be used to query the instrument for the settings currently in use.</p>
<p>To acquire spectral data we can use one of two functions, <code><a href="../reference/acq_raw_spct.html">acq_raw_spct()</a></code> to acquire a single spectrum, or <code><a href="../reference/acq_raw_mspct.html">acq_raw_mspct()</a></code> to acquire a collection of spectra according to a user supplied protocol. In cases when we use HDR (bracketing) or <em>overexpose</em> some part of the spectrum the first data-processing step is to replace the data from the saturated pixels with <code>NA</code>’s using function <code><a href="../reference/trim_counts.html">trim_counts()</a></code>—as the settings used in the acquisition and descriptor of the instrument are stored in the spectral object, this function needs only to be supplied a <code>raw_spct</code> object, unless the user wants to discard more pixels. As pixels neighbouring <em>overexposed</em> pixels are disturbed by the charge <em>overflowing</em> from the saturated wells, these pixels need also to be set as NAs by means of function <code>bleed_nas</code>. If the instrument array contains bad pixels, it is best to replace the data produced by them at this early stage. Function <code><a href="../reference/skip_bad_pixs.html">skip_bad_pixs()</a></code> is useful here and it replaces the bad data with the average of the readings from the neighbouring pixels. The third step after data acquisition, unless the linearisation is done by the instrument, is to linearize the acquired <em>valid</em> raw counts by means of method <code><a href="../reference/linearize_counts.html">linearize_counts()</a></code>. The non-linearity of the detector is related to how “full” are its electron wells, irrespective of whether the electrons originate from measured photons or any other source, consequently the linearisation function should be applied to raw detector counts at this point.</p>
<p>CCD arrays, especially if not cooled, have a significant dark signal. The best approach to remove this <em>background</em> signal is to measure it—to take a spectral reading with the array not exposed to light. This <em>dark spectrum</em> is them subtracted from the one measured in the light. An alternative, with advantages and disadvantages, is to use the signal from pixels corresponding to wavelengths <strong>known</strong> <em>a priori</em> to be absent in the light source being measured. This calculation is done with the <strong>linearized</strong> raw counts by means of method <code>photobiology::fshift()</code> with a pair of suitable wavelength values for <code>range</code>. In the case of measuring transmittance (and absorbance) and reflectance we need to also measure a <em>clear</em> and <em>white</em> reference respectively.</p>
<p>The raw counts after linearisation followed by subtraction of the dark signal are still expressed in number of counts per integration period. As the duration of the integration time is variable, we need to re-express the raw counts as counts-per-second (<em>cps</em>). Once more, the integration time used for the acquisition is stored in the <code>cps_spct</code> object and the conversion can be done by method <code><a href="../reference/raw2cps.html">raw2cps()</a></code> with just this object as input. The values returned, expressed as counts per second, are linearly proportional to the rate at which photons imping each detector pixel. Be aware that as detector quantum yield depends on wavelength, a different multiplier is needed for each pixel to be able to convert the counts-per-second data to units of photons-per-unit-time.</p>
<p>If bracketing for HDR has been used during acquisition, at this point, the values of the <em>cps</em> for each of the bracketed spectra are expressed on the same scale. This means that they can simply be spliced together. The simplest approach possible, used by method <code><a href="../reference/merge_cps.html">merge_cps()</a></code> is to replace the clipped data from saturated pixels (and possibly their neighbours) in the longer integration with data from the same pixels obtained with shorter integration. As we used <code><a href="../reference/trim_counts.html">trim_counts()</a></code> and <code><a href="../reference/bleed_nas.html">bleed_nas()</a></code> on the raw counts, those saturated pixels have already been replaced with <code>NA</code>’s making the operation easy to implement.</p>
<p>After the preceding steps, if the <em>cps</em> or merged <em>cps</em> values are from an irradiance measurement the spectral data are now ready to be multiplied by the calibration constants corresponding to each individual pixel. If the values are to be used for calculation of transmittance or reflectance, all what is left to do is simple arithmetic.</p>
</div>
<div id="additional-corrections" class="section level2">
<h2 class="hasAnchor">
<a href="#additional-corrections" class="anchor"></a>Additional corrections</h2>
<div id="apply-slit-function-correction" class="section level3">
<h3 class="hasAnchor">
<a href="#apply-slit-function-correction" class="anchor"></a>Apply slit function correction</h3>
<p>The slit function describes how monochromatic light “reaches” adjacent pixels which should have been in total darkness had the monochromator been perfect. This is a subtle correction, which will affect only regions of a spectrum where the change in signal strength with wavelength is very steep, such as the UV region of a solar spectrum or a very narrow absorption peak.</p>
<p>The slit function of a spectrometer can be estimated by measuring laser beams at different wavelengths and fitting suitable functions to the observed data. Here we explain how to apply such a function. The slit function is the result of an optical effect, and consequently independent of integration time and other detector settings. Consequently, can be applied to either the merged <em>cps</em> values or after application of a calibration. <strong>Obviously, the stage at which the slit correction is applied needs to match the stage of processing of the data used for estimating the slit function.</strong></p>
<p>The correction to apply to a given pixel depends on the readings of nearby pixels. Some authors recommend to apply this correction recursively, however, we follow the simple approach of applying it only once as an approximation.</p>
</div>
</div>
<div id="measurement-of-spectral-irradiance" class="section level2">
<h2 class="hasAnchor">
<a href="#measurement-of-spectral-irradiance" class="anchor"></a>Measurement of spectral irradiance</h2>
<p>Irradiance estimates are affected by calibration errors, dark electrical noise, dynamic range and stray light. In this section we assume that the available calibration is valid. Random electrical and thermal noise can be averaged out by repeated measurement. Dynamic range depends both on the noise floor and on the resolution of the anologue to digital conversion electronics of the instrument. A way to increase the effective dynamic range is be bracketing intergartion time and splicing/merging the resulting spectra. This is what in digital photography is called HDR or high dynamic range images obtained by merging sets of images obtained at a series of different exposure values. In addition to improved optical design, stray light can be corrected for if it is possible to measure it by itself. This can be acieved by using an optical filter that tranmits radiation of wavelengths causing stray light, but that blocks radiation of wavelengths we are interested in. An additional correction that can be applied is for the slit function of the instrument. The slit function describes how a single wavelength peak (e.g. similar to a laser beam) broadens at the array detector.</p>
<p>Which corrections are needed and which make little difference depends on the type of instrument, the characterisitcs of the light source and the region of the spectrum we are interseted in. Consequently, depending on the circumstances we may want to use different measurement propocols. The high-level functions in the package “guess” the protocol from the set of file names or set of spectra passed as argument. For irradiance calculations three named members are recognized as different measurements in a protocol: <code>"light"</code>, <code>"filter"</code> and <code>"dark"</code>, each of these can be bracketed for integration time. In the case of file names for any of these three members, a vector of file names, is interpreted as a bracketed measurement. In the case of collections of spectra, <code>raw_spct</code> with multiple <code>counts</code> columns are interpreted as bracketed. Of course, at least a <code>"light"</code> member is required as input. If it is missing an empty <code>source_spct</code> object is returned.</p>
<table class="table">
<thead><tr class="header">
<th align="left">Protocol</th>
<th>
<code>light</code> spct</th>
<th>
<code>filter</code> spct</th>
<th>
<code>dark</code> spct</th>
<th>signal level</th>
<th>signal range</th>
<th>speed</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">minimal</td>
<td>short</td>
<td>-</td>
<td>-</td>
<td>high</td>
<td>&lt; 5e1 ??</td>
<td>1/1</td>
</tr>
<tr class="even">
<td align="left">normal</td>
<td>short</td>
<td>-</td>
<td>short</td>
<td>high</td>
<td>&lt; 1e2</td>
<td>1/2</td>
</tr>
<tr class="odd">
<td align="left">corrected</td>
<td>short</td>
<td>short</td>
<td>short</td>
<td>medium</td>
<td>&lt; 1e3</td>
<td>1/3</td>
</tr>
<tr class="even">
<td align="left">cor. brkt</td>
<td>short + long</td>
<td>short + long</td>
<td>short + long</td>
<td>low</td>
<td>&lt; 1e4</td>
<td>1/33</td>
</tr>
</tbody>
</table>
<div id="examples" class="section level3">
<h3 class="hasAnchor">
<a href="#examples" class="anchor"></a>Examples</h3>
<p>We first load the packages to be used, and set the working directory to the location of the example data files included in the package.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(photobiology)
<span class="kw">library</span>(photobiologyWavebands)
<span class="kw">library</span>(ggspectra)
<span class="kw">library</span>(ooacquire)</code></pre></div>
<div id="from-files" class="section level4">
<h4 class="hasAnchor">
<a href="#from-files" class="anchor"></a>From files</h4>
<hr>
In special cases we may need to set a locale matching the language used in the files for month names is not English. In most cases month names are in English, an time zones and decimal markers will be inferred from the data files themselves, making it unnecessary to explicitly pass a locale defintion as argument to funcitons.
<hr>
<p>The first example is the one listed as “minimal” in the table above, we use a single spectrum, using for the dark correction pixels expected to receive no true excitation. For example, those in the UVC region of the spectrum when the light source is sunlight at ground level.</p>
<p>We set a list of file names to be read, with members named according to their role in the measuring protocol.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">file_names &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">light =</span> <span class="st">"light-short.txt"</span>)</code></pre></div>
<p>We subsequently compute the spectral irradiance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">one_file.spct &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/s_irrad_corrected.html">s_irrad_corrected</a></span>(<span class="dt">x =</span> file_names,
                    <span class="dt">descriptor =</span> <span class="kw"><a href="../reference/which_descriptor.html">which_descriptor</a></span>(<span class="st">"2016-10-11"</span> , 
                                                  MAYP11278_descriptors),
                    <span class="dt">correction.method =</span> MAYP11278_ylianttila.mthd)</code></pre></div>
<pre><code>## Descriptor cal_2016a selected for 2016-10-11</code></pre>
<p>As these measurements are of sunlight in a greenhouse we can remove noise from regions known to be zero by replacing with zeros all spectral irradiance values form wavelengths shorter than 290 nm.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">one_file.spct &lt;-<span class="st"> </span><span class="kw">trim_wl</span>(one_file.spct, 
                         <span class="dt">range =</span> <span class="kw">c</span>(<span class="dv">290</span>, <span class="ot">NA</span>), 
                         <span class="dt">use.hinges =</span> <span class="ot">FALSE</span>, 
                         <span class="dt">fill =</span> <span class="dv">0</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">one_file.spct</code></pre></div>
<pre><code>## Object: source_spct [1,421 x 2]
## Wavelength range 251.16 to 898.81 nm, step 0.43 to 0.48 nm 
## Label: light: light-short.txt 
## Measured on 2016-10-11 11:23:05 UTC 
## Time unit 1s
## 
## # A tibble: 1,421 × 2
##    w.length s.e.irrad
## *     &lt;dbl&gt;     &lt;dbl&gt;
## 1    251.16         0
## 2    251.63         0
## 3    252.10         0
## 4    252.58         0
## 5    253.05         0
## 6    253.53         0
## 7    254.00         0
## 8    254.48         0
## 9    254.95         0
## 10   255.43         0
## # ... with 1,411 more rows</code></pre>
<p>We plot the result from “minimal” protocol.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(one_file.spct, <span class="dt">unit.out =</span> <span class="st">"photon"</span>)</code></pre></div>
<p><img src="b-user-guide_files/figure-html/unnamed-chunk-6-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getWhenMeasured</span>(one_file.spct)</code></pre></div>
<pre><code>## [1] "2016-10-11 11:23:05 UTC"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw">getWhatMeasured</span>(one_file.spct))</code></pre></div>
<pre><code>## light: light-short.txt</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getWhereMeasured</span>(one_file.spct)</code></pre></div>
<pre><code>##   lon lat
## 1  NA  NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw">comment</span>(one_file.spct))</code></pre></div>
<pre><code>## Processed on 2017-05-10
## with 's_irrad_corrected()' from 'ooacquire' ver. 0.1.3.9000
## 
## from files:
## light: light-short.txt</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getInstrDesc</span>(one_file.spct)</code></pre></div>
<pre><code>## Data acquired with 'MayaPro2000' s.n. MAYP11278
## grating 'HC1', slit '010s'</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getInstrSettings</span>(one_file.spct)</code></pre></div>
<pre><code>## integ. time (s): 1.6
## total time (s): 4.8
## counts @ peak (% of max): 76</code></pre>
<p>At the other extreme, we can use bracketing, a dark measurement, plus a measurement with a UV-absorbing filter (polycarbonate). The UV absorbing filter allows us to estimate stray light in the UV region. This is the protocol listed as corrected and bracketed (cor. brkt.) in the table above.</p>
<p>We go exactly through the same steps as before, the only difference is the list of file names passed as argument to parameter <code>x</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">file_names &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">light =</span> <span class="kw">c</span>(<span class="st">"light-short.txt"</span>,
                             <span class="st">"light-long.txt"</span>),
                   <span class="dt">filter =</span> <span class="st">"flt-long.txt"</span>,
                   <span class="dt">dark =</span> <span class="kw">c</span>(<span class="st">"dark-short.txt"</span>,
                            <span class="st">"dark-long.txt"</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">five_files.spct &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/s_irrad_corrected.html">s_irrad_corrected</a></span>(<span class="dt">x =</span> file_names,
                    <span class="dt">descriptor =</span> <span class="kw"><a href="../reference/which_descriptor.html">which_descriptor</a></span>(<span class="st">"2016-10-11"</span>, 
                                                  MAYP11278_descriptors),
                    <span class="dt">correction.method =</span> MAYP11278_ylianttila.mthd)</code></pre></div>
<pre><code>## Descriptor cal_2016a selected for 2016-10-11</code></pre>
<p>As these measurements are of sunlight in a greenhouse we can remove noise from regions known to be zero as we did above.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># force to zero wavelengths &lt; 290 nm use only for sunlight, and after checking plot</span>
five_files.spct &lt;-<span class="st"> </span><span class="kw">trim_wl</span>(five_files.spct, 
                           <span class="dt">range =</span> <span class="kw">c</span>(<span class="dv">290</span>, <span class="ot">NA</span>), 
                           <span class="dt">use.hinges =</span> <span class="ot">FALSE</span>, 
                           <span class="dt">fill =</span> <span class="dv">0</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">five_files.spct</code></pre></div>
<pre><code>## Object: source_spct [1,421 x 2]
## Wavelength range 251.16 to 898.81 nm, step 0.43 to 0.48 nm 
## Label: light: light-short.txt, light-long.txt
## filter: flt-long.txt
## dark: dark-short.txt, dark-long.txt 
## Measured on 2016-10-11 11:23:05 UTC 
## Time unit 1s
## 
## # A tibble: 1,421 × 2
##    w.length s.e.irrad
## *     &lt;dbl&gt;     &lt;dbl&gt;
## 1    251.16         0
## 2    251.63         0
## 3    252.10         0
## 4    252.58         0
## 5    253.05         0
## 6    253.53         0
## 7    254.00         0
## 8    254.48         0
## 9    254.95         0
## 10   255.43         0
## # ... with 1,411 more rows</code></pre>
<p>We can now plot the result from complex protocol.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(five_files.spct, <span class="dt">unit.out =</span> <span class="st">"photon"</span>)</code></pre></div>
<p><img src="b-user-guide_files/figure-html/unnamed-chunk-14-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getWhenMeasured</span>(five_files.spct)</code></pre></div>
<pre><code>## [1] "2016-10-11 11:23:05 UTC"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getWhatMeasured</span>(five_files.spct)</code></pre></div>
<pre><code>## [1] "light: light-short.txt, light-long.txt\nfilter: flt-long.txt\ndark: dark-short.txt, dark-long.txt"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getWhereMeasured</span>(five_files.spct)</code></pre></div>
<pre><code>##   lon lat
## 1  NA  NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw">comment</span>(five_files.spct))</code></pre></div>
<pre><code>## Processed on 2017-05-10
## with 's_irrad_corrected()' from 'ooacquire' ver. 0.1.3.9000
## 
## from files:
## light: light-short.txt, light-long.txt
## filter: flt-long.txt
## dark: dark-short.txt, dark-long.txt</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getInstrDesc</span>(five_files.spct)</code></pre></div>
<pre><code>## Data acquired with 'MayaPro2000' s.n. MAYP11278
## grating 'HC1', slit '010s'</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getInstrSettings</span>(five_files.spct)</code></pre></div>
<pre><code>## integ. time (s): 1.6, 7
## total time (s): 4.8, 21
## counts @ peak (% of max): 76</code></pre>
<p>These data are all from the same set of measurements, as one can apply the calculations for the “minimal” protocol to a subset of the data from the “corrected bracketed” protocol. We calculate the differences of the estimates from the “minimal” protocol compared to the complex one.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(<span class="kw">q_irrad</span>(one_file.spct) /<span class="st"> </span><span class="kw">q_irrad</span>(five_files.spct) -<span class="st"> </span><span class="dv">1</span>) *<span class="st"> </span><span class="dv">100</span></code></pre></div>
<pre><code>##     Total 
## 0.4982588 
## attr(,"time.unit")
## [1] "second"
## attr(,"radiation.unit")
## [1] "photon irradiance total"</code></pre>
<p>Differences expressed as percentage for different wavelength ranges.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">kable</span>(
  <span class="kw">t</span>((<span class="kw">q_irrad</span>(one_file.spct, <span class="kw">c</span>(<span class="kw">UV_bands</span>(), <span class="kw">VIS_bands</span>())) /<span class="st"> </span>
<span class="st">     </span><span class="kw">q_irrad</span>(five_files.spct, <span class="kw">c</span>(<span class="kw">UV_bands</span>(), <span class="kw">VIS_bands</span>())) -<span class="st"> </span><span class="dv">1</span>) *<span class="st"> </span><span class="dv">100</span>),
  <span class="dt">digits =</span> <span class="dv">2</span>
)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">UVC.ISO.tr.lo</th>
<th align="right">UVB.ISO</th>
<th align="right">UVA.ISO</th>
<th align="right">Purple.ISO</th>
<th align="right">Blue.ISO</th>
<th align="right">Green.ISO</th>
<th align="right">Yellow.ISO</th>
<th align="right">Orange.ISO</th>
<th align="right">Red.ISO</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">NaN</td>
<td align="right">31.52</td>
<td align="right">-0.69</td>
<td align="right">0.33</td>
<td align="right">0.5</td>
<td align="right">0.48</td>
<td align="right">0.46</td>
<td align="right">0.48</td>
<td align="right">0.47</td>
</tr></tbody>
</table>
</div>
<div id="from-oceanview-files" class="section level4">
<h4 class="hasAnchor">
<a href="#from-oceanview-files" class="anchor"></a>From OceanView files</h4>
<p>Files output by SpectraSuite and OceanView have different header format, but they can be recognized automatically. Consequently there is no difference in the function calls. The filter measurement is not used as it is not suitable for the source spectrum measured, and would be ignored with a warning.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">file_names &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">light =</span> <span class="st">"light_MAYP112785.txt"</span>,
<span class="co">#                    filter = "filter_MAYP112785.txt",</span>
                    <span class="dt">dark =</span> <span class="st">"dark_MAYP112785.txt"</span>)</code></pre></div>
<p>In this case we use a different descriptor definition only because the files acquired with SpectraSuite and OceanView originated from different instruments.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ov_files.raw_mspct &lt;-<span class="st"> </span>
<span class="st">  </span>ooacquire::<span class="kw"><a href="../reference/read_files2mspct.html">read_files2mspct</a></span>(file_names,
                              <span class="dt">descriptor =</span> <span class="kw"><a href="../reference/which_descriptor.html">which_descriptor</a></span>(<span class="st">"2017-01-05"</span>, 
                                                            MAYP112785_descriptors))</code></pre></div>
<pre><code>## Descriptor cal_2016xa selected for 2017-01-05</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(ov_files.raw_mspct[[<span class="dv">1</span>]])</code></pre></div>
<pre><code>## Summary of object: raw_spct [2,068 x 2]
## Wavelength range 198.408 to 1115.677 nm, step 0.406 to 0.472 nm
## Label: File: light_MAYP112785.txt 
## Measured on 2017-01-05 14:22:55 UTC 
## Data acquired with 'MayaPro2000' s.n. MAYP112785
## grating 'HC1', slit '010'
## integ. time (s): 2
## total time (s): 2
## counts @ peak (% of max): NA
##     w.length          counts        
##  Min.   : 198.4   Min.   :  -82.17  
##  1st Qu.: 439.5   1st Qu.: 1625.58  
##  Median : 673.9   Median : 1738.33  
##  Mean   : 668.3   Mean   : 2302.09  
##  3rd Qu.: 900.0   3rd Qu.: 1972.08  
##  Max.   :1115.7   Max.   :46912.83</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(ov_files.raw_mspct[[<span class="dv">2</span>]])</code></pre></div>
<pre><code>## Summary of object: raw_spct [2,068 x 2]
## Wavelength range 198.408 to 1115.677 nm, step 0.406 to 0.472 nm
## Label: File: dark_MAYP112785.txt 
## Measured on 2017-01-05 14:23:55 UTC 
## Data acquired with 'MayaPro2000' s.n. MAYP112785
## grating 'HC1', slit '010'
## integ. time (s): 2
## total time (s): 2
## counts @ peak (% of max): NA
##     w.length          counts      
##  Min.   : 198.4   Min.   : -79.5  
##  1st Qu.: 439.5   1st Qu.:1585.2  
##  Median : 673.9   Median :1661.5  
##  Mean   : 668.3   Mean   :1681.7  
##  3rd Qu.: 900.0   3rd Qu.:1753.5  
##  Max.   :1115.7   Max.   :3665.5</code></pre>
<p>In this case we use a different <code>correction.method</code> definition only because the files acquired with SpectraSuite and OceanView originated from different instruments.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ov_files.spct &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/s_irrad_corrected.html">s_irrad_corrected</a></span>(<span class="dt">x =</span> ov_files.raw_mspct,
                    <span class="dt">correction.method =</span> ooacquire::MAYP112785_ylianttila.mthd)</code></pre></div>
<pre><code>## Warning in trim_counts(.): Negative raw counts in data!
## These are not raw detector counts.

## Warning in trim_counts(.): Negative raw counts in data!
## These are not raw detector counts.</code></pre>
<pre><code>## Warning in range_check(x, cps.cols): Off-range cps values, min =
## -56.5850587835168, max = 20.8861044118045</code></pre>
<pre><code>## Warning in range_check(x, cps.cols): Off-range cps values, min =
## -52.5839216499318, max = 13.3907648317327</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ov_files.spct &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/s_irrad_corrected.html">s_irrad_corrected</a></span>(<span class="dt">x =</span> file_names,
                    <span class="dt">descriptor =</span> <span class="kw"><a href="../reference/which_descriptor.html">which_descriptor</a></span>(<span class="st">"2017-01-05"</span>, 
                                                  MAYP112785_descriptors),
                    <span class="dt">correction.method =</span> ooacquire::MAYP112785_ylianttila.mthd)</code></pre></div>
<pre><code>## Descriptor cal_2016xa selected for 2017-01-05</code></pre>
<pre><code>## Warning in trim_counts(.): Negative raw counts in data!
## These are not raw detector counts.

## Warning in trim_counts(.): Negative raw counts in data!
## These are not raw detector counts.</code></pre>
<pre><code>## Warning in range_check(x, cps.cols): Off-range cps values, min =
## -56.5850587835168, max = 20.8861044118045</code></pre>
<pre><code>## Warning in range_check(x, cps.cols): Off-range cps values, min =
## -52.5839216499318, max = 13.3907648317327</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ov_files.spct</code></pre></div>
<pre><code>## Object: source_spct [1,436 x 2]
## Wavelength range 251.116 to 898.589 nm, step 0.428 to 0.47 nm 
## Label: light: light_MAYP112785.txt
## dark: dark_MAYP112785.txt 
## Measured on 2017-01-05 14:22:55 UTC 
## Time unit 1s
## 
## # A tibble: 1,436 × 2
##    w.length     s.e.irrad
## *     &lt;dbl&gt;         &lt;dbl&gt;
## 1   251.116 -0.0001866098
## 2   251.586  0.0000198477
## 3   252.055  0.0011316948
## 4   252.525 -0.0002764672
## 5   252.994 -0.0009489246
## 6   253.464 -0.0002546838
## 7   253.933 -0.0011313231
## 8   254.403  0.0009336129
## 9   254.872  0.0003924598
## 10  255.341  0.0004984134
## # ... with 1,426 more rows</code></pre>
<p>We can now plot the result from the OceanView files.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(ov_files.spct, <span class="dt">unit.out =</span> <span class="st">"photon"</span>)</code></pre></div>
<p><img src="b-user-guide_files/figure-html/unnamed-chunk-25-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## error!
<span class="kw">plot</span>(<span class="kw">smooth_spct</span>(ov_files.spct, <span class="dt">strength =</span> <span class="dv">5</span>), <span class="dt">unit.out =</span> <span class="st">"photon"</span>)</code></pre></div>
</div>
<div id="from-raw_mspct-objects" class="section level4">
<h4 class="hasAnchor">
<a href="#from-raw_mspct-objects" class="anchor"></a>From <code>"raw_mspct"</code> objects</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">descriptor &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/which_descriptor.html">which_descriptor</a></span>(<span class="kw">getWhenMeasured</span>(white_LED.raw_mspct$light))
irrad01.spct &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/s_irrad_corrected.html">s_irrad_corrected</a></span>(<span class="dt">x =</span> white_LED.raw_mspct,
                       <span class="dt">descriptor =</span> descriptor,
                       <span class="dt">correction.method =</span> MAYP11278_ylianttila.mthd)</code></pre></div>
<pre><code>## Warning in ooacquire::uvb_corrections(x = x, spct.names = spct.names,
## stray.light.method = correction.method[["stray.light.method"]], : Too low
## cps in filter reference region, setting method to 'simple'.</code></pre>
<pre><code>## Warning in filter_correction(x = y[[spct.names["light"]]], flt =
## y[[spct.names["filter"]]], : No stray light correction applied to long end
## of spectrum.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">irrad01.spct</code></pre></div>
<pre><code>## Object: source_spct [1,421 x 2]
## Wavelength range 251.16 to 898.81 nm, step 0.43 to 0.48 nm 
## what label: light
## user.label label: osram06 
## Measured on 2016-12-01 10:08:16 UTC 
## Time unit 1s
## 
## # A tibble: 1,421 × 2
##    w.length   s.e.irrad
## *     &lt;dbl&gt;       &lt;dbl&gt;
## 1    251.16 0.004314156
## 2    251.63 0.004184169
## 3    252.10 0.003847835
## 4    252.58 0.004763573
## 5    253.05 0.005094774
## 6    253.53 0.003838450
## 7    254.00 0.004133885
## 8    254.48 0.002904687
## 9    254.95 0.003052997
## 10   255.43 0.003011101
## # ... with 1,411 more rows</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(irrad01.spct, <span class="dt">unit.out =</span> <span class="st">"photon"</span>)</code></pre></div>
<p><img src="b-user-guide_files/figure-html/unnamed-chunk-29-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getWhenMeasured</span>(irrad01.spct)</code></pre></div>
<pre><code>## [1] "2016-12-01 10:08:16 UTC"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getWhereMeasured</span>(irrad01.spct)</code></pre></div>
<pre><code>##   lon lat
## 1  NA  NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getWhatMeasured</span>(irrad01.spct)</code></pre></div>
<pre><code>## $what
## [1] "light"
## 
## $user.label
## [1] "osram06"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw">comment</span>(irrad01.spct))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getInstrDesc</span>(irrad01.spct)</code></pre></div>
<pre><code>## Data acquired with 'MayaPro2000' s.n. MAYP11278
## grating 'HC1', slit '010s'</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getInstrSettings</span>(irrad01.spct)</code></pre></div>
<pre><code>## integ. time (s): 0.32, 3.2
## total time (s): 5.11, 6.39
## counts @ peak (% of max): 94.3</code></pre>
</div>
</div>
</div>
<div id="measurement-of-spectral-transmittance" class="section level2">
<h2 class="hasAnchor">
<a href="#measurement-of-spectral-transmittance" class="anchor"></a>Measurement of spectral transmittance</h2>
<p>As for irradiance, transmittance estimates are affected by dark electrical noise, dynamic range and stray light. Random electrical and thermal noise can be averaged out by repeated measurement. Dynamic range depends both on the noise floor and on the resolution of the anologue to digital conversion electronics of the instrument. A way to increase the effective dynamic range is bracketing integrartion time and splicing/merging the resulting spectra. This is what in digital photography is called HDR or high dynamic range images obtained by merging sets of images obtained at a series of different exposure values. In addition to improved optical design, stray light can be corrected for if it is possible to measure it by itself. This can be achieved by use of an optical filter that transmits radiation of wavelengths causing stray light, but that blocks radiation of wavelengths we are interested in. An additional correction that can be applied is for the slit function of the instrument. The slit function describes how a single wavelength peak (e.g. similar to a laser beam) broadens at the array detector.</p>
<p>Which corrections are needed and which make little difference depends on the type of instrument, the characterisitcs of the sample being measured and of the light source and the region of the spectrum we are interseted in. Consequently, depending on the circumstances we may want to use different measurement propocols. The high-level functions in the package “guess” the protocol from the set of file names or set of spectra passed as argument. For irradiance calculations three named members are recognized as different measurements in a protocol: <code>"sample"</code>, <code>"reference"</code>, <code>"filter"</code>, and <code>"dark"</code>, each of these can be bracketed for integration time. In the case of file names for any of these three members, a vector of file names, is interpreted as a bracketed measurement. In the case of collections of spectra, <code>raw_spct</code> with multiple <code>counts</code> columns are interpreted as bracketed. Of course, at least a <code>"sampel"</code> and <code>"reference"</code> members are required as input. If either or both are missing an empty <code>filter_spct</code> object is returned.</p>
<table class="table">
<thead><tr class="header">
<th align="left">Protocol</th>
<th>
<code>sample</code> spct</th>
<th>
<code>reference</code> spct</th>
<th>
<code>filter</code> spct</th>
<th>
<code>dark</code> spct</th>
<th>signal range</th>
<th>speed</th>
<th></th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="left">minimal</td>
<td>short</td>
<td>short</td>
<td>-</td>
<td>-</td>
<td>&lt; 5e1 ??</td>
<td>1/1</td>
<td></td>
</tr>
<tr class="even">
<td align="left">normal</td>
<td>short</td>
<td>short</td>
<td>-</td>
<td>short</td>
<td>&lt; 1e2</td>
<td>1/3</td>
<td></td>
</tr>
<tr class="odd">
<td align="left">nor. brkt</td>
<td>short + long</td>
<td>short + long</td>
<td>-</td>
<td>short + long</td>
<td>&lt; 1e3</td>
<td>1/33</td>
<td></td>
</tr>
<tr class="even">
<td align="left">(corrected)</td>
<td>short</td>
<td>short</td>
<td>short</td>
<td>short</td>
<td>&lt; 1e3</td>
<td>1/5</td>
<td></td>
</tr>
<tr class="odd">
<td align="left">(cor. brkt)</td>
<td>short + long</td>
<td>short + long</td>
<td>short + long</td>
<td>short</td>
<td>&lt; 5e3</td>
<td>1/55</td>
<td></td>
</tr>
</tbody>
</table>
<p>The last two prorocols, using a <code>"filter"</code> measurement seem unlikely to be useful in practice, but I intend to do some tests in the future to test this.</p>
<div id="examples-1" class="section level3">
<h3 class="hasAnchor">
<a href="#examples-1" class="anchor"></a>Examples</h3>
<hr>
In special cases we may need to set a locale matching the language used in the files for month names is not English. In most cases month names are in English, an time zones and decimal markers will be inferred from the data files themselves, making it unnecessary to explicitly pass a locale defintion as argument to funcitons.
<hr>
<div id="from-files-1" class="section level4">
<h4 class="hasAnchor">
<a href="#from-files-1" class="anchor"></a>From files</h4>
<p>The first example is the one listed as “minimal” in the table above, we use two spectra, one for sample and one for reference, using for the dark correction pixels expected to receive no true excitation. For example, those in the UVC region of the spectrum when the light source is sunlight at ground level.</p>
<p>We set a list of file names to be read, with members named according to their role in the measuring protocol.</p>
</div>
<div id="from-a-raw_mspct-object" class="section level4">
<h4 class="hasAnchor">
<a href="#from-a-raw_mspct-object" class="anchor"></a>From a <code>"raw_mspct"</code> object</h4>
<p>A suitable <code>"raw_mspct"</code> can be acquired directly from a spectrometer using functions in this package, or built by reading files obtained using Ocean Optics SpectraSuite software. In the case of spectral objects we can query the measurement date and use it to find an instrument descriptor containing a valid calibration. Although for transmittance calculation the calubration multipliers for irradiance are not used, the calibrated wavelengths are. If the wavelength calibration stored in the spectrometer’s non-volatile memory is valid, it is not necessary to pass a descriptor argument to the function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">descriptor &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/which_descriptor.html">which_descriptor</a></span>(<span class="kw">getWhenMeasured</span>(blue_filter.raw_mspct$sample))
tfr01.spct &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/s_fraction_corrected.html">s_fraction_corrected</a></span>(<span class="dt">x =</span> blue_filter.raw_mspct,
                       <span class="dt">descriptor =</span> descriptor,
                       <span class="dt">correction.method =</span> ooacquire::MAYP11278_ylianttila.mthd,
                       <span class="dt">dyn.range =</span> <span class="fl">3e2</span>)</code></pre></div>
<pre><code>## Warning in range_check(x, strict.range = strict.range): Off-range
## transmittance values [0.00072...1.2] instead of [0..1]

## Warning in range_check(x, strict.range = strict.range): Off-range
## transmittance values [0.00072...1.2] instead of [0..1]</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tfr01.spct</code></pre></div>
<pre><code>## Object: filter_spct [2,068 x 2]
## Wavelength range 187.82 to 1117.14 nm, step 0.41 to 0.48 nm 
## what label: sample
## user.label label: UQG_Blue 
## Measured on 2016-11-28 14:46:25 UTC 
## 
## # A tibble: 2,068 × 2
##    w.length   Tfr
##       &lt;dbl&gt; &lt;dbl&gt;
## 1    187.82    NA
## 2    188.30    NA
## 3    188.78    NA
## 4    189.26    NA
## 5    189.73    NA
## 6    190.21    NA
## 7    190.69    NA
## 8    191.17    NA
## 9    191.64    NA
## 10   192.12    NA
## # ... with 2,058 more rows</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(tfr01.spct)</code></pre></div>
<pre><code>## Warning: Removed 415 rows containing non-finite values (stat_peaks).</code></pre>
<p><img src="b-user-guide_files/figure-html/unnamed-chunk-35-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">tfr01.spct &lt;-<span class="st"> </span><span class="kw">clip_wl</span>(tfr01.spct, <span class="dt">range =</span> <span class="kw">c</span>(<span class="dv">355</span>, <span class="dv">1100</span>))</code></pre></div>
<pre><code>## Off-range transmittance values [0.00072...1.2] instead of  [0..1]</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(tfr01.spct, <span class="dt">unit.out =</span> <span class="st">"photon"</span>, <span class="dt">w.band =</span> <span class="kw">VIS_bands</span>())</code></pre></div>
<pre><code>## Warning: Removed 58 rows containing non-finite values (stat_peaks).</code></pre>
<p><img src="b-user-guide_files/figure-html/unnamed-chunk-37-1.png" width="672"></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getWhenMeasured</span>(tfr01.spct)</code></pre></div>
<pre><code>## [1] "2016-11-28 14:46:25 UTC"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getWhereMeasured</span>(tfr01.spct)</code></pre></div>
<pre><code>##   lon lat
## 1  NA  NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getWhatMeasured</span>(tfr01.spct)</code></pre></div>
<pre><code>## $what
## [1] "sample"
## 
## $user.label
## [1] "UQG_Blue"</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">cat</span>(<span class="kw">comment</span>(tfr01.spct))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getInstrDesc</span>(tfr01.spct)</code></pre></div>
<pre><code>## Data acquired with 'MayaPro2000' s.n. MAYP11278
## grating 'HC1', slit '010s'</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">getInstrSettings</span>(tfr01.spct)</code></pre></div>
<pre><code>## integ. time (s): 0.488, 4
## total time (s): 20, 20
## counts @ peak (% of max): 75</code></pre>
</div>
<div id="from-a-raw_mspct-object-with-a-known-reference" class="section level4">
<h4 class="hasAnchor">
<a href="#from-a-raw_mspct-object-with-a-known-reference" class="anchor"></a>From a <code>raw_mspct</code> object with a known reference</h4>
<p>In contrast to the previous example, we will here assume that the reference is not 100% clear, and that we know its transmittance to be 0.95.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">descriptor &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/which_descriptor.html">which_descriptor</a></span>(<span class="kw">getWhenMeasured</span>(blue_filter.raw_mspct$sample))
tfr02.spct &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/s_fraction_corrected.html">s_fraction_corrected</a></span>(<span class="dt">x =</span> blue_filter.raw_mspct,
                       <span class="dt">ref.value =</span> <span class="fl">0.95</span>,
                       <span class="dt">descriptor =</span> descriptor,
                       <span class="dt">correction.method =</span> MAYP11278_ylianttila.mthd,
                       <span class="dt">dyn.range =</span> <span class="fl">3e2</span>)</code></pre></div>
<pre><code>## Warning in range_check(x, strict.range = strict.range): Off-range
## transmittance values [0.00072...1.2] instead of [0..1]

## Warning in range_check(x, strict.range = strict.range): Off-range
## transmittance values [0.00072...1.2] instead of [0..1]</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(tfr02.spct)</code></pre></div>
<pre><code>## Warning: Removed 415 rows containing non-finite values (stat_peaks).</code></pre>
<p><img src="b-user-guide_files/figure-html/unnamed-chunk-42-1.png" width="672"></p>
<p>In the next example, we use a spectrum to describe the reference’s spectral properties.</p>
<p>In contrast to the previous example where we calculated transmittance, we will here calculate reflectance assuming that the reference is not 100% white, and that we know its spectral reflectance.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">descriptor &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/which_descriptor.html">which_descriptor</a></span>(<span class="kw">getWhenMeasured</span>(blue_filter.raw_mspct$sample))
rfr01.spct &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw"><a href="../reference/s_fraction_corrected.html">s_fraction_corrected</a></span>(<span class="dt">x =</span> blue_filter.raw_mspct,
                       <span class="dt">ref.value =</span> <span class="kw">as.reflector_spct</span>(white_body.spct) *<span class="st"> </span><span class="fl">0.97</span>,
                       <span class="dt">descriptor =</span> descriptor,
                       <span class="dt">correction.method =</span> MAYP11278_ylianttila.mthd,
                       <span class="dt">dyn.range =</span> <span class="fl">3e2</span>,
                       <span class="dt">qty.out =</span> <span class="st">"Rfr"</span>,
                       <span class="dt">type =</span> <span class="st">"total"</span>)</code></pre></div>
<pre><code>## Warning in range_check(x, strict.range = strict.range): Off-range
## reflectance values [0.00072...1.2] instead of [0..1]

## Warning in range_check(x, strict.range = strict.range): Off-range
## reflectance values [0.00072...1.2] instead of [0..1]</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(rfr01.spct)</code></pre></div>
<pre><code>## Warning: Removed 415 rows containing non-finite values (stat_peaks).</code></pre>
<p><img src="b-user-guide_files/figure-html/unnamed-chunk-44-1.png" width="672"></p>
</div>
</div>
</div>
<div id="irradiance-calibration" class="section level2">
<h2 class="hasAnchor">
<a href="#irradiance-calibration" class="anchor"></a>Irradiance calibration</h2>
<div id="calculating-calibration-constants" class="section level3">
<h3 class="hasAnchor">
<a href="#calculating-calibration-constants" class="anchor"></a>Calculating calibration constants</h3>
</div>
<div id="applying-calibration-constants" class="section level3">
<h3 class="hasAnchor">
<a href="#applying-calibration-constants" class="anchor"></a>Applying calibration constants</h3>
</div>
</div>
<div id="high-level-functions" class="section level2">
<h2 class="hasAnchor">
<a href="#high-level-functions" class="anchor"></a>High level functions</h2>
</div>
<div id="definig-new-protocols" class="section level2">
<h2 class="hasAnchor">
<a href="#definig-new-protocols" class="anchor"></a>Definig new protocols</h2>
<p>You can compose from simple functions different measurement protocols and data processing sequences. This is the reason why they have been designed as a set of small functions, each one doing a single operation.</p>
<p>Please see the example scripts installed with the package.</p>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li><a href="#introduction">Introduction</a></li>
      <li><a href="#functions">Functions</a></li>
      <li><a href="#workflow">Workflow</a></li>
      <li><a href="#additional-corrections">Additional corrections</a></li>
      <li><a href="#measurement-of-spectral-irradiance">Measurement of spectral irradiance</a></li>
      <li><a href="#measurement-of-spectral-transmittance">Measurement of spectral transmittance</a></li>
      <li><a href="#irradiance-calibration">Irradiance calibration</a></li>
      <li><a href="#high-level-functions">High level functions</a></li>
      <li><a href="#definig-new-protocols">Definig new protocols</a></li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright">
  <p>Developed by Pedro J. Aphalo, Lasse Ylianttila.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
