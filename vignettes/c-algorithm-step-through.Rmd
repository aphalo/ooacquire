---
title: "Algorithms"
subtitle: "`ooacquire` `r packageVersion('ooacquire')`"
author: "Pedro J. Aphalo"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: yes
vignette: >
  %\VignetteIndexEntry{Algorithms}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

In this vignette we will walk through the different steps used in the conversion of raw counts into physical quantities. Different protocols can be used, and not all those implemented are exemplified. The facilities in the package also allow users to implement their own measurement and correction protocols. _It must be, however, always kept in mind that protocols and calibrations go hand in hand:_ **For each different measuring protocol or new raw conversion algorithm new calibration multipliers will be required**. In the case of new measurement protocols new calibration data and validation measurements will be needed. However, for new raw data conversion protocols recalculation of new calibration multipliers from existing raw-counts and calibration-lamp data may be enough. In this last case existing validation measurements against other instruments can be reused if available.

***
## Preliminaries

```{r, echo=FALSE, message=FALSE}
require("knitr")
dirpath <- system.file("extdata", package="ooacquire")
opts_knit$set(autodep = TRUE, fig.width=8, fig.asp=0.5, out.width = '90%')
# options(photobioloy.verbose = TRUE)
```

We start by loading the R packages we will use.

```{r}
library(ggplot2)
library(ggspectra)
library(photobiology)
library(photobiologyWavebands)
library(ooacquire)
library(magrittr)
```

## Spectral irradiance for a continuous source

We will step through the different stages of the algorithm used, plotting the spectra at each step along the way. We use raw counts data, included in the package, from the measurement of sunlight at ground level with an Ocean Optics Maya 2000 Pro array spectrometer. Before the computations walk-trhough we will describe how the data and metadata are stored. We will also show the use of a high level function that automatically through all steps needed to convert raw spectromter counts into irradiance.

We will use energy photon/quantum units throughout, for which we override the default use of energy units.

```{r}
photon_as_default()
```


### The raw counts data and computed spectral irradiance

Spectral data were acquired using function `acquire_irrad_interactive()` from this package. This function implements several measurement protocols from which the user can chose. RAW-counts data are returned as a collection of RAW spectra, contains also metadata including a descriptor of the instrument and a descriptor of the instrument settings used. The instrument descriptor contains also the instrument calibration data when available. So irrespective of the approach and number of measurements needed for measuring one irradiance spectrum, all the data and metadata are contained in a single R object of class `raw_mspct`. If the calibration data is included in the metadata, all information needed to compute irradiance is stored in this single object.

The data contains a measurement of the _light_ source, a measurement of the same light source through a polycarbonate _filter_ and a reference or _dark_ measurement. Each of the three spectra in these collection is a `raw_spct` object.

```{r}
names(sun001.raw_mspct)
```

The spectrum for the light measurement contains multiple columns, one for each of three different integration times used.

```{r}
colnames(sun001.raw_mspct[["light"]])
```

Summary in addition to displaying the summary for the columns, displays the most important metadata attributes, including the integration times and total measurement times.

```{r}
summary(sun001.raw_mspct[["light"]])
```

We can explore the structure of the object, to see how data and metadata are stored using `str()` as shown below. We here limit the nesting level so that the output is not too large.

```{r}
# not run
str(sun001.raw_mspct[["light"]], max.level = 2)
```
A formatted printout of the instrument setting provides important information. The maximum count value observed relative to the sensor's maximum allowed counts is specially important for diagnostics of data quality, as a value of 100% indicates clipping while low values, say less than 70% result in decreased dynamic range due to sensor dark noise.

```{r}
getInstrSettings(sun001.raw_mspct[["light"]])
```

As with any other R object we access an attribute and use indexing to extract a given metadata value.

```{r}
attr(sun001.raw_mspct[["light"]], which = "instr.desc")$spectrometer.name
```

In normal use, we calculate irradiance from a raw-counts data set stored as a collection in a `raw_mspct` object using the high-level function `s_irrad_corrected()`. We pass as first argument the object containing the RAW counts and corresponding metadata and the _correction method_ to be used in the conversion of the RAW counts into irradiance.

```{r, fig.width=8, fig.asp=0.5}
sun001_recalc.spct <-
  s_irrad_corrected(sun001.raw_mspct, 
                    correction.method = ooacquire::MAYP11278_ylianttila.mthd)
```

The R object returned by `s_irrad_corrected()` belongs to class `"source_spct"` (defined in package 'photobiology') for which summary and plotting methods are available. We first have a quick look at this object. In the output bellow we will notice that the six RAW measurements, three in the light and three in the dark have been used to calculate a single estimate of spectral irradiance. We can also see that the range of wavelengths is narrower as only wavelengths for which calibration data exists have been retained.

```{r}
summary(sun001_recalc.spct)
```

By plotting the spectral irradiance data, either in whole or a range of wavelengths we can better see the shape of the solar spectrum at ground level, and in this example also obtain summaries for the irradiance in different wavebands.

```{r, fig.width=8, fig.asp=0.5}
autoplot(sun001_recalc.spct)
```
Using a different correction method, that assumes that the measurements are of sunlight at ground level and consequently spectral irradiance for wavelengths shorter than xxx nm should be indistinguishable from zero.

```{r, fig.width=8, fig.asp=0.5}
sun001_recalc.spct <-
  s_irrad_corrected(sun001.raw_mspct, 
                    correction.method = ooacquire::MAYP11278_sun.mthd)
```

The R object returned by `s_irrad_corrected()` belongs to class `"source_spct"` (defined in package 'photobiology') for which summary and plotting methods are available. We first have a quick look at this object. In the output bellow we will notice that the six RAW measurements, three in the light and three in the dark have been used to calculate a single estimate of spectral irradiance. We can also see that the range of wavelengths is narrower as only wavelengths for which calibration data exists have been retained.

```{r}
summary(sun001_recalc.spct)
```

By plotting the spectral irradiance data, either in whole or a range of wavelengths we can better see the shape of the emission spectrum of the lamp, and in this example also obtain summaries for the irradiance in different wavebands.

```{r, fig.width=8, fig.asp=0.5}
autoplot(sun001_recalc.spct)
```
We can also use the same function to obtain counts per second.

```{r, fig.width=8, fig.asp=0.5}
sun001_recalc.cps_spct <-
  s_irrad_corrected(sun001.raw_mspct, 
                    correction.method = ooacquire::MAYP11278_ylianttila.mthd,
                    return.cps = TRUE)
```

```{r, eval=FALSE}
get_attributes(sun001_recalc.cps_spct)
```

```{r}
summary(sun001_recalc.cps_spct)
```

By plotting the raw counts expressed as counts per second we can see that the shape of the curve is affected by the varying sensitivity of the spectrometer to photons of different wavelengths.

```{r, fig.width=8, fig.asp=0.5}
autoplot(sun001_recalc.cps_spct)
```
We can in a separate step convert the counts per second data to irradadiance by applying the calibration.

```{r, eval = FALSE}
sun001_recalc.source_spct <- cps2irrad(sun001_recalc.cps_spct)
```

```{r, eval = FALSE}
summary(sun001_recalc.source_spct)
```

```{r, fig.width=8, fig.asp=0.5, eval = FALSE}
autoplot(sun001_recalc.source_spct)
```

### Step-by-step walk through

In this section we will apply one by one the different computation steps staring from RAW spectral data until we obtain spectral irradiance, the same spectrum shown in the figure above.

We have described in the previous section the structure of the object containing the RAW counts data. As we saw above, measurements consisted in two measurements using two different integration times. In addition to different integration times, the number of "scans" was adjusted so that each of the two spectra contain data for a similar total length of time. The three spectra, _light_, _filter_ and _dark_ where acquired in succesion and using the same settings in the spectrometer.

When dealing with raw detector counts one needs to be aware that the array detector in array spectrometers saturates at a certain number of counts, ranging from 256 to 64000 or more counts. This inforamtion is stored as part of the metadata. 

```{r}
getInstrDesc(sun001.raw_mspct[["light"]])$max.counts
```

Plotting the two bracketed spectra shows the effect of using the optimal integration time plus an integration 10 times longer. In other words if more photons imping on a detector cell/pixel during one intergration event (or "scan") than needed to reach 64000 counts, the reading remains at 64000 counts. This is usually called "signal clipping", i.e., the tips of peaks are truncated or off scale.

```{r, fig.width=8, fig.asp=0.5}
autoplot(sun001.raw_mspct[["light"]])
```
In the figure above, we can see that in addition to clipping, increasing the integration time, at least in some spectrometers significantly increases the "noise floor" or dark readings. This is also true for the measurements done in darkness. In these spectra, we can also easily see several spikes caused by "hot pixels" in the detector (over-responding pixels). In the figure below we can see the effect of the filter.

```{r, fig.width=8, fig.asp=0.5}
autoplot(sun001.raw_mspct[["filter"]])
```
In this third figure, we have a look at the spectrum measured in drakness. This spectrometer in particular has the peculiarity that the effect of warming on dark noise depends on wavelength.

```{r, fig.width=8, fig.asp=0.5}
autoplot(sun001.raw_mspct[["dark"]])
```
The **first step** in the processing is substituting data from bad pixels by values interpolated from the adjacent fixels. Which pixels are bad is recorded in the calibration data. What this step achieves can be clearly seen by comparing the plots before (see above) and after this step (see below). As in most array spectrometers pixel resolution is better than optical resolution this introduces little error, except possibly in the case of very narrow peaks.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(sun001.raw_mspct)) {
  sun001.raw_mspct[[m]] <-
    skip_bad_pixs(sun001.raw_mspct[[m]])
  print(autoplot(sun001.raw_mspct[[m]]) + ggtitle(m))
}
```
**Note:** When bad-pixel information is not available, automatic despiking can be used instead, but it needs care not to accidentaly remove true peaks from the data.

The **second step** is to replace saturated (clipped) pixel data, with the missing data marker `NA`. As `NA` values are not plotted pixels exactly equal to the maximum possible reading disappear from the plot.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(sun001.raw_mspct)) {
  sun001.raw_mspct[[m]] <-
    trim_counts(sun001.raw_mspct[[m]])
  print(autoplot(sun001.raw_mspct[[m]]) + ggtitle(m))
}
```

An important consideration is that when a pixel _well_ fills with electrical charge some of the excessive charge migrates to nearby pixels. How many nearby pixels are affected depends on the detector type, but it is at most a few tens of pixels. So in this **third step**, pixels neighbouring those set to `NA` in the second step are also set to `NA`. By default we replace the 10 nearest non-saturated pixels also by `NA`. 

```{r, fig.width=8, fig.asp=0.5}
for (m in names(sun001.raw_mspct)) {
  sun001.raw_mspct[[m]] <-
    bleed_nas(sun001.raw_mspct[[m]])
  print(autoplot(sun001.raw_mspct[[m]]) + ggtitle(m))
}
```

The response of array detectors is not perfectly linear _vs._ to the number of photons received. Most precisely when the number of counts gets near the maximum value, the sensitivity to additional photons slightly decreases. This is a result of how "full" the sensor wells are, irrespective of the source of the charge. Consequently this correction should be applied before subtraction of the dark reading.

The **fourth step** is to apply a linearisation function, in most cases supplied with the instrument and possibly stored in the instrument firmware. This function is part of the calibration data for the instrument that is stored as part of the metadata during acquisition of the spectra. Given that linearization corrects for a decrease in sensitivity at counts approaching the maximum, some values can exceed the maximum (64000 in this case).

```{r, fig.width=8, fig.asp=0.5}
for (m in names(sun001.raw_mspct)) {
  sun001.raw_mspct[[m]] <-
    linearize_counts(sun001.raw_mspct[[m]])
  print(autoplot(sun001.raw_mspct[[m]], ylim = c(NA, 65000)) + ggtitle(m))
}
```

The first few pixels in the detector of most array spectrometers are covered and never exposed to light photons. These can be used as a dark reference to correct for thermal noise. This step may appear redundant, but _might_ help in cases when instrument temperature is not the same during the _light_ and _dark_ measurements. An alternative is to use pixels known not to be exposed to radiation from the light source, but within the useful measurement range of the instrument. Sunlight at ground level is known to lack UV-C photons, so wavelengths between 250 nm and 290 nm can used as dark reference for this light source. Consequently, as the **fifth step** we remove an estimate of dark signal based on these "non-excited pixels". As seen in the plots, this step effectively removes the overall dark signal from both _light_ and _dark_ measurements. We can, however, also see that there is residual dark noise remaining at pixel level, not all pixels have the same noise floor. Part of this variation is systematic, and some may be random. As we used a total measurement time of 120 s much of the random noise must have canceled out through averaging.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(sun001.raw_mspct)) {
  sun001.raw_mspct[[m]] <-
    fshift(sun001.raw_mspct[[m]], range = c(218.5,228.5))
  print(autoplot(sun001.raw_mspct[[m]], ylim = c(NA, 65000)) + ggtitle(m))
}
```
In the last plot above we can see that the correction has resulted in slightly negative values in darkness. If the bump in the noise floor, caused by warming, is consistent among all three measurements, it should cancell out. 

At this point we have "clean" RAW counts data. The **sixth step** is to convert these raw counts into counts per second. As the integration time for each spectrum is stored together with the RAW count data, the function call is simple. After this step, the data acquired using different integration times are expressed in the same units. We take advantage of this to plot using different colours the data from the two different "bracketed" integration times. Blue corresponds to the shortest and optimal integration time, and red to the longer one. Here we over-plot the two separate spectra.

```{r, fig.width=8, fig.asp=0.5}
sun001.cps_mspct <- cps_mspct()
for (m in names(sun001.raw_mspct)) {
  sun001.cps_mspct[[m]] <-
    raw2cps(sun001.raw_mspct[[m]])
  print(
    ggplot(sun001.cps_mspct[[m]], aes(x = w.length)) +
      ylim(NA, 5e5) +
      geom_line(aes(y = cps_1), color = "blue") +
      geom_line(aes(y = cps_2), color = "red") +
      ggtitle(m)
  )
}
```

The **seventh step** splicing the three pairs of "bracketed" _light_, _filter_ and _dark_ counts-per-second spectra into three combined spectra.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(sun001.cps_mspct)) {
  sun001.cps_mspct[[m]] <-
    merge_cps(sun001.cps_mspct[[m]])
  print(autoplot(sun001.cps_mspct[[m]], ylim = c(NA, 5e5)) + ggtitle(m))
}
```

In the **eighth step** we subtract the dark signal from the _light_ and _filter_ measurements. This reduces the remaining noise.

```{r, fig.width=8, fig.asp=0.5}
sun001.cps_mspct[["light"]] <- 
  sun001.cps_mspct[["light"]] - sun001.cps_mspct[["dark"]]

sun001.cps_mspct[["filter"]] <- 
  sun001.cps_mspct[["filter"]] - sun001.cps_mspct[["dark"]]

sun001.cps_mspct[["dark"]] <- NULL

autoplot(sun001.cps_mspct) + ggtitle("Dark subtracted")
```

At this point we have a clean counts-per-second spectrum. The **ninth step** is to apply the calibration multipliers and any additional instrument specific correction to obtain spectral irradiance in a `"source_spct"` object.

```{r, fig.width=8, fig.asp=0.5, eval = FALSE}
sun001.irrad_spct <- cps2irrad(sun001.cps_spct)
autoplot(sun001.irrad_spct)
```

In an optional, final **tenth step** we apply smoothing to remove some of the noise.

```{r, fig.width=8, fig.asp=0.5, eval = FALSE}
sun001.irrad_spct <- smooth_spct(sun001.irrad_spct)
autoplot(sun001.irrad_spct)
```
With an LED source, at least in the case of our Maya 2000 Pro, we do not need to worry about stray light. However, when we measure light sources with a significant emission in the infra-red above 1000 nm, stray light becomes a problem. In addition sources with narrow peaks of emission may benefit from deconvolution of a measured slit function.

### Tungsten halogen lamp

For our instrument, stray light originates mostly in the infra-red and it can be a serious problem when trying to precisely measuring sunlight or incandescent lamps. For this example we use data acquired using a different protocol, which includes three measurements, being the additional one, a measurement through a filter used to estimate stray light in the UV-region. In this case a UV-cut and IR-pass filter (a piece of clear polycarbonate).

The data contains a measurement of the _light_ source directly and through a _filter_ and a reference _dark_ measurement.

```{r}
names(halogen.raw_mspct)
```

The spectrum for the light measurement contains two columns with RAW-counts data.

```{r}
names(halogen.raw_mspct[["light"]])
```

Summary in addition to displaying the summary for the columns, displays the most important metadata attributes.

```{r}
summary(halogen.raw_mspct[["light"]])
```

As above for the LED lamp, we first calculate spectral irradiance from a set of raw-counts spectral data using the high-level function `s_irrad_corrected()`.

```{r, fig.width=8, fig.asp=0.5}
halogen.spct <-
  s_irrad_corrected(halogen.raw_mspct, correction.method= MAYP11278_ylianttila.mthd)
autoplot(halogen.spct)
```

In the example above we called the functions used for each of the steps in the computation individually, saving the intermediate results so as to be able to show the partly processed data at each step. The functions, however, support the use of pipes as they all have as their first parameter the one accepting the R object returned by the previous stage.

We first use a "pipe" to apply the same initial processing steps as for the LED bulb data in the previous section. The main difference is that we use as internal instrument dark reference those pixels that never are exposed to radiation. For our instrument they correspond to wavelengths 187.82 nm to 189.26 nm. We obtain this time three spectra containing counts-per-second data.

```{r}
halogen.cps_mspct <- cps_mspct()
for (m in names(halogen.raw_mspct)) {
  halogen.raw_mspct[[m]] %>%
    skip_bad_pixs() %>%
    trim_counts() %>%
    bleed_nas() %>%
    linearize_counts() %>%
    fshift(range = c(187.82,189.26)) %>%
    raw2cps() %>% 
    merge_cps() -> halogen.cps_mspct[[m]]
}
names(halogen.cps_mspct)
```

We plot the returned spectra, both in full, and the UV region by itself. By careful comparison of these later plots one can see that the signal for _filter_ is larger than for _dark_. As we know from specifications and measurements that the filter used blocks radiation in this region, the difference is due to stray light (radiation of longer wavelengths being detected as ultraviolet).

```{r, fig.width=8, fig.asp=0.5}
for (m in names(halogen.cps_mspct)) {
  print(autoplot(halogen.cps_mspct[[m]]) + ggtitle(m))
  print(autoplot(halogen.cps_mspct[[m]], range = c(250, 410)) + ggtitle(m))
}
```

In the next step we subtract the _dark_ reading from both the _light_ and _filter_ readings, and copy attributes, including instrument settings and calibration data.

```{r}
halogen01.cps_mspct <- cps_mspct()
for (m in setdiff(names(halogen.cps_mspct), "dark")) {
  halogen01.cps_mspct[[m]] <- halogen.cps_mspct[[m]] - halogen.cps_mspct[["dark"]]
  halogen01.cps_mspct[[m]] <- 
    copy_attributes(halogen.cps_mspct[[m]],
                    halogen01.cps_mspct[[m]],
                    copy.class = FALSE)
}
names(halogen01.cps_mspct)
```

```{r, fig.width=8, fig.asp=0.5}
for (m in names(halogen01.cps_mspct)) {
  print(autoplot(halogen01.cps_mspct[[m]]) + ggtitle(m))
  print(autoplot(halogen01.cps_mspct[[m]], range = c(250, 410)) + ggtitle(m))
}
```

As we can see in the plots above, a small amount of stray light is present in both spectra in the UV region. We apply a filter correction using a simple method based on a fixed transmittance value. We set `flt.Tfr = 0.9` as these is a good estimate of the transmittance of polycarbonate to the stray light.

```{r}
halogen_corrected.cps_spct <-
  filter_correction(halogen01.cps_mspct[["light"]], 
                    halogen01.cps_mspct[["filter"]],
                    stray.light.method = "original",
                    flt.Tfr = 0.9)
names(halogen_corrected.cps_spct)
getTimeUnit(halogen_corrected.cps_spct)
```

```{r, fig.width=8, fig.asp=0.5}
autoplot(halogen_corrected.cps_spct)
autoplot(halogen_corrected.cps_spct, range = c(250, 410))
mean(clip_wl(halogen_corrected.cps_spct, range = c(250, 300))[["cps"]])
```

The average counts-per-second remaining after correcting for stray light is very small. In the next step we apply the calibration multipliers to obtain spectral irradiance.

```{r}
cps2irrad(halogen_corrected.cps_spct) -> halogen.source_spct
names(halogen.source_spct)
```

The spectrum displays some noise at the shortest wavelengths and some interference patterns at the long end. The interference patterns come from the light bulb, but the random noise of increasing amplitude with decreasing wavelength in the UV region is due to the spectrometer.

We can compute some photon ratios, expressed as $mmol\, mol^{-1}$ to diagnose whether the stray light is well controlled.

```{r}
q_ratio(halogen.source_spct, list(UVC(), UVB(), UVA()), PAR()) * 1e3
```

Smoothing can sometimes help, but it can also introduce bias. It should be used with care and always checking the output. 

Using defaults, we get some minor artifacts in the UV region, but preserve the data pattern in the NIR.

```{r}
halogen_sm0.source_spct <- smooth_spct(halogen.source_spct)
```

```{r, fig.width=8, fig.asp=0.5}
autoplot(halogen_sm0.source_spct)
autoplot(halogen_sm0.source_spct, range = c(250, 410))
```
How much difference did smoothing do?

```{r}
q_ratio(halogen_sm0.source_spct, list(UVC(), UVB(), UVA()), PAR()) * 1e3
```

With overriding the default arguments we better remove random noise and a small "bump" at 320 nm. Setting setting `strength` to `1` instead of `3` smooths the random noise but not this small peak (not shown). In the infra-red most of the wavy pattern is also removed. So, smoothing can be useful, but it can also remove real features, and one needs to decide if these features are of interest or not, based on other sources of information.

```{r}
halogen_sm.source_spct <- smooth_spct(halogen.source_spct, method = "supsmu", strength = 3)
```

```{r, fig.width=8, fig.asp=0.5}
autoplot(halogen_sm.source_spct)
autoplot(halogen_sm.source_spct, range = c(250, 410))
```

How much difference did smoothing do?

```{r}
q_ratio(halogen_sm.source_spct, list(UVC(), UVB(), UVA()), PAR()) * 1e3
```

## Slit function correction

When measuring spectra containing narrow peaks or steep slopes the shape of the slit function will affect the apparent width of peaks or the apparent steepness of the slope. The slit through which light enters the instrument has a finite width and angle of acceptance for radiation. Consequently, even when measuring true monochromatic radiation from a laser photons will imping on multiple array pixels/wells. The pixel corresponding to the wavelength of the radiation receives the most photons, but the neighbouring pixels receive a decreasing number of photons as the distance from the "correct" target pixel increases. The wider the slit used, the broader the "false" peak observed for monochromatic light. The shape and width of this _slit function_ depends not only on the width of the slit but also on other features of the optical bench of the instrument. In array spectrometers the slit function also depends on wavelength as the length of the path from the grating to the detector is not constant.

However, if the slit function is known, it can be used to remove its influence from a measured spectrum, in simpler words it can be used to partly reconstruct the structure of original light source spectrum. In the case of the two examples above, applying this correction would make little difference. In the case of the solar spectrum and discharge lamps this further step improves the estimates for spectral irradiance.

Too see the effect of this correction we need to look at individual peaks in a spectrum. We use data for a mercury lamp.

The data contains a measurement of the _light_ source and a reference _dark_ measurement.

```{r}
names(xenon_flash.raw_mspct)
```

The spectrum for the light measurement contains one column with RAW-counts data as no bracketing was used.

```{r}
names(xenon_flash.raw_mspct[["light"]])
```

Summary in addition to displaying the summary for the columns, displays the most important metadata attributes.

```{r}
summary(xenon_flash.raw_mspct[["light"]])
```

In the case of these data, the concept of counts-per-second does not apply as the flash discharge is shorter than the integration time, and unknown. The relevant reference is one exposure event and the quantity to estimate is spectral fluence in $J m^{-2}$.

```{r}
getInstrSettings(xenon_flash.raw_mspct[["light"]])$num.exposures
```

As above for the LED lamp, we first calculate spectral fluence from a set of raw-counts spectral data using the high-level function `s_irrad_corrected()`.

```{r, fig.width=8, fig.asp=0.5}
xenon_flash.spct <-
  s_irrad_corrected(xenon_flash.raw_mspct, correction.method = MAYP11278_ylianttila.mthd)
getTimeUnit(xenon_flash.spct)
```
```{r, fig.width=8, fig.asp=0.5}
autoplot(xenon_flash.spct, range = c(315, NA))
```


```{r, fig.width=8, fig.asp=0.5}
xenon_flash.cps_spct <-
  s_irrad_corrected(xenon_flash.raw_mspct, correction.method= MAYP11278_ylianttila.mthd, return.cps = TRUE)
getTimeUnit(xenon_flash.cps_spct)
```
```{r, fig.width=8, fig.asp=0.5}
autoplot(xenon_flash.cps_spct, range = c(315, NA))
```

