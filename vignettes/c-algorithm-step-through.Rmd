---
title: "Algorithms"
subtitle: "`ooacquire` `r packageVersion('ooacquire')`"
author: "Pedro J. Aphalo"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: yes
vignette: >
  %\VignetteIndexEntry{Algortihms}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introdcution

In this vignette we will walk through the different steps used in the conversion of raw counts into physical quantites. Different protocols can be used, and not all those implemented are exemplified. The facilities in the package also allow users to implement their own measurement and correction protocols. _It must be, however, always kept in mind that protocols and calibrations go hand in han:_ **For each different protocol new calibration data will be required**. In many cases new calibration and validation measurements will be needed, but sometimes just recalculation of new calibration constants from existing raw-counts and calibration-lamp data may be enough.

***
## Code examples

All examples in vignettes use data and files included in the package. Data files in formats _foreign_ to R, are stored in the `"extdata"` folder, as is the norm for R packages.

_To reproduce any of the examples which use files as data input, it is best to make a local copy of the whole `"extdata"` folder._ The files used in examples are organized into subfolders, but all example code assumes that its in being run with `"extdata"` or a copy of it as the current _working_ folder.

```{r, eval=-2}
folderpath <- system.file("extdata",package="ooacquire")
file.copy(from = folderpath, to = ".", recursive = TRUE)
```
***

## Irradiance

We will step through the different steps of the algorithm used, plotting the spectra at each step along the way. We use raw counts data, included in the package, to make building this vignette easier. At the same time we show how raw data acquire outwith R can be also processed with the package.

## Interactive acquisition of spectral irradiance

```{r, echo=FALSE, message=FALSE}
require("knitr")
dirpath <- system.file("extdata", package="ooacquire")
opts_knit$set(autodep = TRUE, root.dir = dirpath, fig.width=8, fig.asp=0.5, out.width = '90%')
# options(photobioloy.verbose = TRUE)
```

We first load the R packages to be used.

```{r}
library(ggplot2)
library(ggspectra)
library(photobiology)
library(photobiologyWavebands)
library(ooacquire)
library(magrittr)
```

### Household white LED bulb

We will read data from the measurement of the irradiance under a white LED light source---_Osram LED Star classic A 60 E27_. It was measured with a Ocean Optics, Maya 2000 Pro spectrometer, using the function `acquire_irrad_interactive()`.

We calculate irradiance from a set of raw-counts spectral data using a high-level function.

```{r, fig.width=8, fig.asp=0.5}
LED_lamp_recalc.spct <-
  s_irrad_corrected(white_LED_2min.raw_mspct, 
                    correction.method= ooacquire::MAYP11278_ylianttila.mthd)
plot(LED_lamp_recalc.spct)
plot(LED_lamp_recalc.spct, range = c(250, 410))
```

We next print the collection of spectra containing raw counts data. The protocol used consisted in one light measurement and one dark measurement, each with bracketing of the integration time.

```{r}
white_LED.raw_mspct
```
Ploting the three bracketed spectra shows the raw data. The detector saturates at approximately 64000 counts.

```{r, fig.width=8, fig.asp=0.5}
plot(white_LED_2min.raw_mspct[["light"]])
```

```{r, fig.width=8, fig.asp=0.5}
plot(white_LED_2min.raw_mspct[["dark"]])
```

The first step in the processing is removal of bad pixels, as recorded in the calibration data.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.raw_mspct[[m]] <-
    skip_bad_pixs(white_LED_2min.raw_mspct[[m]])
  print(plot(white_LED_2min.raw_mspct[[m]]) + ggtitle(m))
}
```

Next step is to replace saturated pixel data, with the missing data marked `NA`.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.raw_mspct[[m]] <-
    trim_counts(white_LED_2min.raw_mspct[[m]])
  print(plot(white_LED_2min.raw_mspct[[m]]) + ggtitle(m))
}
```

Saturated pixels can affect the readings from nearby pixels through charge migration, so we need to also tag as `NA`s these additional pixels.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.raw_mspct[[m]] <-
    bleed_nas(white_LED_2min.raw_mspct[[m]])
  print(plot(white_LED_2min.raw_mspct[[m]]) + ggtitle(m))
}
```

Next we need to apply a linearization function, as detector response is not linear---saturation is gradual.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.raw_mspct[[m]] <-
    linearize_counts(white_LED_2min.raw_mspct[[m]])
  print(plot(white_LED_2min.raw_mspct[[m]]) + ggtitle(m))
}
```

We may next remove an estimate of dark signal based on reference pixels not expected to be excited. This step may apear redundant, but _might_ help in cases when instrument temperature is not stable.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.raw_mspct[[m]] <-
    fshift(white_LED_2min.raw_mspct[[m]], range = c(250,290))
  print(plot(white_LED_2min.raw_mspct[[m]]) + ggtitle(m))
}
```

Now we can convert the raw counts into counts per second.

```{r, fig.width=8, fig.asp=0.5}
white_LED_2min.cps_mspct <- cps_mspct()
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.cps_mspct[[m]] <-
    raw2cps(white_LED_2min.raw_mspct[[m]])
  print(
    ggplot(white_LED_2min.cps_mspct[[m]], aes(x = w.length)) +
      geom_line(aes(y = cps_1), color = "blue") +
      geom_line(aes(y = cps_2), color = "red") +
      geom_line(aes(y = cps_3), color = "green") +
      ggtitle(m)
  )
}
```

Next splicing of the bracketed integrations.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.cps_mspct)) {
  white_LED_2min.cps_mspct[[m]] <-
    merge_cps(white_LED_2min.cps_mspct[[m]])
  print(plot(white_LED_2min.cps_mspct[[m]]) + ggtitle(m))
}
```

We now subtract the dark signal from the light measurement.

```{r, fig.width=8, fig.asp=0.5}
white_LED_2min.cps_spct <- 
  white_LED_2min.cps_mspct[["light"]] - white_LED_2min.cps_mspct[["dark"]]
white_LED_2min.cps_spct <- 
  copy_attributes(white_LED_2min.raw_mspct[["light"]],
                  white_LED_2min.cps_spct,
                  copy.class = FALSE)
plot(white_LED_2min.cps_spct) + ggtitle("Dark subtracted")
```

```{r, fig.width=8, fig.asp=0.5}
white_LED_2min.spct <- cps2irrad(white_LED_2min.cps_spct)
plot(white_LED_2min.spct)
```

We can finally smooth-out some of the noise.

```{r, fig.width=8, fig.asp=0.5}
white_LED_2min.spct <- smooth_spct(white_LED_2min.spct)
plot(white_LED_2min.spct)
```
With an LED source, at least in the case of our Maya 2000 Pro, we do not need to worry about stray light. However, when we measure light sources with a significant emission in the infra-red above 1000 nm, stray light becomes a problem. In addition sources with narrow peaks of emission may benefit from deconvolution of a measured slit function.

### Tungsten halogen lamp


We calculate irradiance from a set of raw-counts spectral data using a high-level function.

```{r, fig.width=8, fig.asp=0.5}
halogen.spct <-
  s_irrad_corrected(halogen.raw_mspct, correction.method= MAYP11278_ylianttila.mthd)
plot(halogen.spct)
plot(halogen.spct, range = c(250, 410))
```


We print the object with the raw counts data. The protocol used, in this case included a measurement with a UV-pass filter (polycarbonate).

```{r}
halogen.raw_mspct
```

We first use a "pipe" to apply the same initial processing steps as for the LED bulb data in the previous section.

```{r}
halogen.cps_mspct <- cps_mspct()
for (m in names(halogen.raw_mspct)) {
  halogen.raw_mspct[[m]] %>%
    skip_bad_pixs() %>%
    trim_counts() %>%
    bleed_nas() %>%
    linearize_counts() %>%
    fshift(range = c(187.82,189.26)) %>%
    raw2cps() %>% 
    merge_cps() -> halogen.cps_mspct[[m]]
}
halogen.cps_mspct
```

```{r, fig.width=8, fig.asp=0.5}
for (m in names(halogen.cps_mspct)) {
  print(plot(halogen.cps_mspct[[m]]) + ggtitle(m))
  print(plot(halogen.cps_mspct[[m]], range = c(250, 410)) + ggtitle(m))
}
```

We substract the dark reading from both the light and filter measurements, and copy attributes, including instrument settings and calibration data.

```{r}
halogen01.cps_mspct <- cps_mspct()
for (m in setdiff(names(halogen.cps_mspct), "dark")) {
  halogen01.cps_mspct[[m]] <- halogen.cps_mspct[[m]] - halogen.cps_mspct[["dark"]]
  halogen01.cps_mspct[[m]] <- 
    copy_attributes(halogen.cps_mspct[[m]],
                    halogen01.cps_mspct[[m]],
                    copy.class = FALSE)
}
halogen01.cps_mspct
```

```{r, fig.width=8, fig.asp=0.5}
for (m in names(halogen01.cps_mspct)) {
  print(plot(halogen01.cps_mspct[[m]]) + ggtitle(m))
  print(plot(halogen01.cps_mspct[[m]], range = c(250, 410)) + ggtitle(m))
}
```

As we can see in the plots above, a small amount of stray light is present in both spectra in the UV region. We apply a filter correction using a simple method based on a fixed transmittance value. By trial an error a flt.Tfr value > 1 gives best correction, which is odd...

```{r}
halogen_corrected.cps_spct <-
  filter_correction(halogen01.cps_mspct[["light"]], 
                    halogen01.cps_mspct[["filter"]],
                    stray.light.method = "original",
                    flt.Tfr = 1.4)
```

```{r, fig.width=8, fig.asp=0.5}
plot(halogen_corrected.cps_spct)
plot(halogen_corrected.cps_spct, range = c(250, 410))
mean(clip_wl(halogen_corrected.cps_spct, range = c(250, 300))[["cps"]])
```

```{r}
cps2irrad(halogen_corrected.cps_spct) -> halogen.source_spct
```

```{r, fig.width=8, fig.asp=0.5}
plot(halogen.source_spct)
plot(halogen.source_spct, range = c(250, 410))
```

```{r}
q_ratio(halogen.source_spct, list(UVC(), UVB(), UVA()), PAR()) * 1e3
```

```{r}
cps2irrad(halogen_corrected.cps_spct) %>%
  smooth_spct(method = "supsmu", strength = 3) -> halogen.source_spct
```

```{r, fig.width=8, fig.asp=0.5}
plot(halogen.source_spct)
plot(halogen.source_spct, range = c(250, 410))
```

```{r}
q_ratio(halogen.source_spct, list(UVC(), UVB(), UVA()), PAR()) * 1e3
```

## Coming soon

Step by step application of slit fucntion tail correction.


