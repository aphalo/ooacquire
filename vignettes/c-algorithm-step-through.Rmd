---
title: "Algorithms"
subtitle: "`ooacquire` `r packageVersion('ooacquire')`"
author: "Pedro J. Aphalo"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette:
    toc: yes
vignette: >
  %\VignetteIndexEntry{Algortihms}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

In this vignette we will walk through the different steps used in the conversion of raw counts into physical quantities. Different protocols can be used, and not all those implemented are exemplified. The facilities in the package also allow users to implement their own measurement and correction protocols. _It must be, however, always kept in mind that protocols and calibrations go hand in hand:_ **For each different measuring protocol or new raw conversion algorithm new calibration multipliers will be required**. In the case of new measurement protocols new calibration data and validation measurements will be needed. However, for new raw data conversion protocols recalculation of new calibration multipliers from existing raw-counts and calibration-lamp data may be enough. In this last case existing validation measurements against other instruments can be reused if available.

***
## Code examples

All examples in vignettes use data objects included in the package.

## Irradiance

We will step through the different stages of the algorithm used, plotting the spectra at each step along the way. We use raw counts data, included in the package, to make building this vignette easier. At the same time we show how raw data acquired outside R can be processed with the package.

## Spectral irradiance from RAW detector counts

```{r, echo=FALSE, message=FALSE}
require("knitr")
dirpath <- system.file("extdata", package="ooacquire")
opts_knit$set(autodep = TRUE, fig.width=8, fig.asp=0.5, out.width = '90%')
# options(photobioloy.verbose = TRUE)
```

We start by loading the R packages we will use.

```{r}
library(ggplot2)
library(ggspectra)
library(photobiology)
library(photobiologyWavebands)
library(ooacquire)
library(magrittr)
```

### Household white LED bulb

We read RAW-detector-counts data from the measurement of irradiance under a white LED light source---_Osram LED Star classic A 60 E27_. Spectral data were acquired with an Ocean Optics Maya 2000 Pro spectrometer, using function `acquire_irrad_interactive()` from this package. This function implements several measurement protocols from which the user can chose. However, RAW counts data returned as a collection of RAW spectra, contains also metadata including a descriptor of the instrument and a descriptor of the instrument settings used.

The data contains a measurement of the _light_ source and a reference _dark_ measurement.

```{r}
names(white_LED_2min.raw_mspct)
```

The spectrum for the light measurement contains multiple columns.

```{r}
names(white_LED_2min.raw_mspct[["light"]])
```

Summary in addition to displaying the summary for the columns, displays the most important metadata attributes.

```{r}
summary(white_LED_2min.raw_mspct[["light"]])
```


Here we extract a single metadata item from one of the spectra.

```{r}
attr(white_LED_2min.raw_mspct[["light"]], which = "instr.desc")$spectrometer.name
```

To see every single data and metadata item stored we can use `str()` as shown below, but not run given the length of the output.

```{r, eval=FALSE}
# not run
summary(white_LED_2min.raw_mspct[["light"]])
```

In normal use, we calculate irradiance from a set of raw-counts spectral data using the high-level function `s_irrad_corrected()`. We pass as first argument the object containing the RAW counts and corresponding metadata and the _correction method_ to be used in the conversion of the RAW counts into irradiance.

```{r, fig.width=8, fig.asp=0.5}
LED_lamp_recalc.spct <-
  s_irrad_corrected(white_LED_2min.raw_mspct, 
                    correction.method= ooacquire::MAYP11278_ylianttila.mthd)
```

The R object returned by `s_irrad_corrected()` belongs to class `"source_spct"` (defined in package 'photobiology') for which summary and plotting methods are available. We first have a quick look at this object. In the output bellow we will notice that the six RAW measurements, three in the light and three in the dark have been used to calculate a single estimate of spectral irradiance. We can also see that the range of wavelengths is narrower as only wavelengths for which calibration data exists have been retained.

```{r}
summary(LED_lamp_recalc.spct)
```

By plotting the spectral irradiance data, either in whole or a range of wavelengths we can better see the shape of the emission spectrum of the lamp, and in this example also obtain summaries for the irradiance in different wavebands.

```{r, fig.width=8, fig.asp=0.5}
autoplot(LED_lamp_recalc.spct)
```

What we show bellow are the individual computation steps that the RAW spectral data have gone through to obtain the spectral irradiance spectrum shown in the figure above.
We next print the collection of spectra containing raw counts data. The protocol used consisted in one light measurement and one dark measurement, each with bracketing of the integration time.

We have described above the structure of the object containing the RAW counts data. As we saw above, measurements consisted in three measurements using three different integration times. In addition to different integration times, the number of "scans" was adjusted so that the three spectra consist in the average of scans covering the same total length of time.

Plotting the three bracketed spectra shows the effect of using the optimal integration time plus two longer integration times. To understand the figure one needs to be aware that the spectrometer detector saturates at approximately 64000 counts. In other words if more photons imping the detector cell/pixel than needed for 64000 counts, the reading remains at 64000 counts. This is usually called "signal clipping".

```{r, fig.width=8, fig.asp=0.5}
autoplot(white_LED_2min.raw_mspct[["light"]])
```

In the figure above, we can see that in addition to clipping, increasing the integration time, at least in some spectrometers significantly increases the "noise floor" or dark readings. This is even clearly seen in the measurements done in darkness. In this spectra, we can easily see some hot pixels in the detector (bad pixels).

```{r, fig.width=8, fig.asp=0.5}
autoplot(white_LED_2min.raw_mspct[["dark"]])
```

The **first step** in the processing is removal of bad pixels, as recorded in the calibration data. What this step achieves can be clearly seen by comparing the plots before and after this step.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.raw_mspct[[m]] <-
    skip_bad_pixs(white_LED_2min.raw_mspct[[m]])
  print(autoplot(white_LED_2min.raw_mspct[[m]]) + ggtitle(m))
}
```

The **second step** is to replace saturated (clipped) pixel data, with the missing data marked `NA`. As `NA` values are not plotted pixels exactly equal to the maximum possible reading disappear from the plot.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.raw_mspct[[m]] <-
    trim_counts(white_LED_2min.raw_mspct[[m]])
  print(autoplot(white_LED_2min.raw_mspct[[m]]) + ggtitle(m))
}
```

An important consideration is that when a pixel _well_ fills some of the excessive charge migrates to nearby pixels. How many nearby pixels are affected depends on the detector type, but it is at most a few tens of pixels. So in this **third step**, pixels neighbouring those set to `NA` in the second step are also set to `NA`.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.raw_mspct[[m]] <-
    bleed_nas(white_LED_2min.raw_mspct[[m]])
  print(autoplot(white_LED_2min.raw_mspct[[m]]) + ggtitle(m))
}
```

The response of array detectors is not linear in response to the number of photons received. Most precisely when the number of counts gets near the maximum value, the sensitivity to additional photons slightly decreases. This is a results of how "full" the sensor wells are, irrespective of the source of the charge. Consequently this correction should be applied before subtraction of the dark reading.
The **fourth step** is to apply a linearisation function, in most cases supplied with the instrument and possibly stored in the instrument firmware. This function is part of the calibration data for the instrument that is stored as part of the metadata during acquisition of the spectra.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.raw_mspct[[m]] <-
    linearize_counts(white_LED_2min.raw_mspct[[m]])
  print(autoplot(white_LED_2min.raw_mspct[[m]], ylim = c(NA, 65000)) + ggtitle(m))
}
```

The first few pixels in the detector of most array spectrometers are covered and never exposed to light photons. These can be used as a dark reference to correct for thermal noise. This step may appear redundant, but _might_ help in cases when instrument temperature is not the same during the _light_ and _dark_ measurements. An alternative is to use pixels known to be not exposed to radiation from the light source, but within the useful measurement range of the instrument. A white LED lamp is not expected to emit UV-C, so wavelengths between 250 nm and 290 nm can used. Consequently, as the **fifth step** we remove an estimate of dark signal based on these "non-excited pixels". As seen in the plots, this step effectively removes the overall dark signal from both _light_ and _dark_ measurements. We can, however, also see that there is residual dark noise remaining at pixel level, not all pixels have the same noise floor. Part of this variation is systematic, and some may be random. As we used a total measurement time of 120 s much of the random noise must have cancelled out.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.raw_mspct[[m]] <-
    fshift(white_LED_2min.raw_mspct[[m]], range = c(250,290))
  print(autoplot(white_LED_2min.raw_mspct[[m]], ylim = c(NA, 65000)) + ggtitle(m))
}
```

At this point we have "clean" RAW counts data. The **sixth step** is to convert these raw counts into counts per second. As the integration time for each spectrum is stored together with the RAW count data, the function call is simple. After this step, the data acquired using different integration times are expressed in the same units. We take advantage of this to plot using different colours the data from the three different "bracketed" integration times. Blue corresponds to the shortest and optimal integration time, and green to the longest one used. Here we over-plot the three separate spectra.

```{r, fig.width=8, fig.asp=0.5}
white_LED_2min.cps_mspct <- cps_mspct()
for (m in names(white_LED_2min.raw_mspct)) {
  white_LED_2min.cps_mspct[[m]] <-
    raw2cps(white_LED_2min.raw_mspct[[m]])
  print(
    ggplot(white_LED_2min.cps_mspct[[m]], aes(x = w.length)) +
      ylim(NA, 40000) +
      geom_line(aes(y = cps_1), color = "blue") +
      geom_line(aes(y = cps_2), color = "red") +
      geom_line(aes(y = cps_3), color = "green") +
      ggtitle(m)
  )
}
```

The **seventh step** splicing of the _light_ and _dark_ three counts-per-second spectra each into a single combined spectrum.

```{r, fig.width=8, fig.asp=0.5}
for (m in names(white_LED_2min.cps_mspct)) {
  white_LED_2min.cps_mspct[[m]] <-
    merge_cps(white_LED_2min.cps_mspct[[m]])
  print(autoplot(white_LED_2min.cps_mspct[[m]], ylim = c(NA, 40000)) + ggtitle(m))
}
```

In the **eigth step** we subtract the dark signal from the light measurement. This reduces the remaining noise.

```{r, fig.width=8, fig.asp=0.5}
white_LED_2min.cps_spct <- 
  white_LED_2min.cps_mspct[["light"]] - white_LED_2min.cps_mspct[["dark"]]
white_LED_2min.cps_spct <- 
  copy_attributes(white_LED_2min.raw_mspct[["light"]],
                  white_LED_2min.cps_spct,
                  copy.class = FALSE)
autoplot(white_LED_2min.cps_spct) + ggtitle("Dark subtracted")
```

At this point we have a clean counts-per-second spectrum. The **ninth step** is to apply the calibration multipliers and any additional instrument specific correction to obtain spectral irradiance in a `"source_spct"` object.

```{r, fig.width=8, fig.asp=0.5}
white_LED_2min.spct <- cps2irrad(white_LED_2min.cps_spct)
autoplot(white_LED_2min.spct)
```

In an optional, final **tenth step** we apply smoothing to remove some of the noise.

```{r, fig.width=8, fig.asp=0.5}
white_LED_2min.spct <- smooth_spct(white_LED_2min.spct)
autoplot(white_LED_2min.spct)
```
With an LED source, at least in the case of our Maya 2000 Pro, we do not need to worry about stray light. However, when we measure light sources with a significant emission in the infra-red above 1000 nm, stray light becomes a problem. In addition sources with narrow peaks of emission may benefit from deconvolution of a measured slit function.

### Tungsten halogen lamp

For our instrument, stray light originates mostly in the infra-red and it can be a serious problem when trying to precisely measuring sunlight or incandescent lamps. For this example we use data acquired using a different protocol, which includes three measurements, being the additional one, a measurement through a filter used to estimate stray light in the UV-region. In this case a UV-cut and IR-pass filter (a piece of clear polycarbonate).

The data contains a measurement of the _light_ source directly and through a _filter_ and a reference _dark_ measurement.

```{r}
names(halogen.raw_mspct)
```

The spectrum for the light measurement contains two columns with RAW-counts data.

```{r}
names(halogen.raw_mspct[["light"]])
```

Summary in addition to displaying the summary for the columns, displays the most important metadata attributes.

```{r}
summary(halogen.raw_mspct[["light"]])
```

As above for the LED lamp, we first calculate spectral irradiance from a set of raw-counts spectral data using the high-level function `s_irrad_corrected()`.

```{r, fig.width=8, fig.asp=0.5}
halogen.spct <-
  s_irrad_corrected(halogen.raw_mspct, correction.method= MAYP11278_ylianttila.mthd)
autoplot(halogen.spct)
```

In the example above we called the functions used for each of the steps in the computation individually, saving the intermediate results so as to be able to show the partly processed data at each step. The functions, however, support the use of pipes as they all have as their first parameter the one accepting the R object returned by the previous stage.

We first use a "pipe" to apply the same initial processing steps as for the LED bulb data in the previous section. The main difference is that we use as internal instrument dark reference those pixels that never are exposed to radiation. For our instrument they correspond to wavelengths 187.82 nm to 189.26 nm. We obtain this time three spectra containing counts-per-second data.

```{r}
halogen.cps_mspct <- cps_mspct()
for (m in names(halogen.raw_mspct)) {
  halogen.raw_mspct[[m]] %>%
    skip_bad_pixs() %>%
    trim_counts() %>%
    bleed_nas() %>%
    linearize_counts() %>%
    fshift(range = c(187.82,189.26)) %>%
    raw2cps() %>% 
    merge_cps() -> halogen.cps_mspct[[m]]
}
names(halogen.cps_mspct)
```

We plot the returned spectra, both in full, and the UV region by itself. By careful comparison of these later plots one can see that the signal for _filter_ is larger than for _dark_. As we know from specifications and measurements that the filter used blocks radiation in this region, the difference is due to stray light (radiation of longer wavelengths being detected as ultraviolet).

```{r, fig.width=8, fig.asp=0.5}
for (m in names(halogen.cps_mspct)) {
  print(autoplot(halogen.cps_mspct[[m]]) + ggtitle(m))
  print(autoplot(halogen.cps_mspct[[m]], range = c(250, 410)) + ggtitle(m))
}
```

In the next step we subtract the _dark_ reading from both the _light_ and _filter_ readings, and copy attributes, including instrument settings and calibration data.

```{r}
halogen01.cps_mspct <- cps_mspct()
for (m in setdiff(names(halogen.cps_mspct), "dark")) {
  halogen01.cps_mspct[[m]] <- halogen.cps_mspct[[m]] - halogen.cps_mspct[["dark"]]
  halogen01.cps_mspct[[m]] <- 
    copy_attributes(halogen.cps_mspct[[m]],
                    halogen01.cps_mspct[[m]],
                    copy.class = FALSE)
}
names(halogen01.cps_mspct)
```

```{r, fig.width=8, fig.asp=0.5}
for (m in names(halogen01.cps_mspct)) {
  print(autoplot(halogen01.cps_mspct[[m]]) + ggtitle(m))
  print(autoplot(halogen01.cps_mspct[[m]], range = c(250, 410)) + ggtitle(m))
}
```

As we can see in the plots above, a small amount of stray light is present in both spectra in the UV region. We apply a filter correction using a simple method based on a fixed transmittance value. We set `flt.Tfr = 0.9` as these is a good estimate of the transmittance of polycarbonate to the stray light.

```{r}
halogen_corrected.cps_spct <-
  filter_correction(halogen01.cps_mspct[["light"]], 
                    halogen01.cps_mspct[["filter"]],
                    stray.light.method = "original",
                    flt.Tfr = 0.9)
names(halogen_corrected.cps_spct)
getTimeUnit(halogen_corrected.cps_spct)
```

```{r, fig.width=8, fig.asp=0.5}
autoplot(halogen_corrected.cps_spct)
autoplot(halogen_corrected.cps_spct, range = c(250, 410))
mean(clip_wl(halogen_corrected.cps_spct, range = c(250, 300))[["cps"]])
```

The average counts-per-second remaining after correcting for stray light is very small. In the next step we apply the calibration multipliers to obtain spectral irradiance.

```{r}
cps2irrad(halogen_corrected.cps_spct) -> halogen.source_spct
names(halogen.source_spct)
```

The spectrum displays some noise at the shortest wavelengths and some interference patterns at the long end. The interference patterns come from the light bulb, but the random noise of increasing amplitude with decreasing wavelength in the UV region is due to the spectrometer.

We can smooth this random noise if desired.

```{r, fig.width=8, fig.asp=0.5}
autoplot(halogen.source_spct)
autoplot(halogen.source_spct, range = c(250, 410))
```

We can compute some photon ratios, expressed as $mmol\, mol^{-1}$ to diagnose whether the stray light is well controlled.

```{r}
q_ratio(halogen.source_spct, list(UVC(), UVB(), UVA()), PAR()) * 1e3
```

Smoothing can sometimes help, but it can also introduce bias. It should be used with care and always checking the output. The arguments and method chosen remove random noise and a small "bump" at 320 nm, setting strength to `1` instead of `3` smooths the random noise but not this small peak (not shown). In the infra-red most of the wavy pattern is also removed. So, smoothing can be useful, but it can also remove real features, and one needs to decide if these features are of interest or not, based on other sources of information.

```{r}
halogen_sm.source_spct <- smooth_spct(halogen.source_spct, method = "supsmu", strength = 3)
```

```{r, fig.width=8, fig.asp=0.5}
autoplot(halogen_sm.source_spct)
autoplot(halogen_sm.source_spct, range = c(250, 410))
```

How much difference did smoothing do?

```{r}
q_ratio(halogen.source_spct, list(UVC(), UVB(), UVA()), PAR()) * 1e3
```

## Slit function correction

When measuring spectra containing narrow peaks or steep slopes the shape of the slit function will affect the apparent width of peaks or the apparent steepness of the slope. The slit through which light enters the instrument has a finite width and angle of acceptance for radiation. Consequently, even when measuring true monochromatic radiation from a laser photons will imping on multiple array pixels/wells. The pixel corresponding to the wavelength of the radiation receives the most photons, but the neighbouring pixels receive a decreasing number of photons as the distance from the "correct" target pixel increases. The wider the slit used, the broader the "false" peak observed for monochromatic light. The shape and width of this _slit function_ depends not only on the width of the slit but also on other features of the optical bench of the instrument. In array spectrometers the slit function also depends on wavelength as the length of the path from the grating to the detector is not constant.

However, if the slit function is known, it can be used to remove its influence from a measured spectrum, in simpler words it can be used to partly reconstruct the structure of original light source spectrum. In the case of the two examples above, applying this correction would make little difference. In the case of the solar spectrum and discharge lamps this further step improves the estimates for spectral irradiance.

Too see the effect of this correction we need to look at individual peaks in a spectrum. We use data for a mercury lamp.

The data contains a measurement of the _light_ source and a reference _dark_ measurement.

```{r}
names(xenon_flash.raw_mspct)
```

The spectrum for the light measurement contains one column with RAW-counts data as no bracketing was used.

```{r}
names(xenon_flash.raw_mspct[["light"]])
```

Summary in addition to displaying the summary for the columns, displays the most important metadata attributes.

```{r}
summary(xenon_flash.raw_mspct[["light"]])
```

In the case of these data, the concept of counts-per-second does not apply as the flash discharge is shorter than the integration time, and unknown. The relevant reference is one exposure event and the quantity to estimate is spectral fluence in $J m^{-2}$.

```{r}
getInstrSettings(halogen.raw_mspct[["light"]])$num.exposures
getInstrSettings(xenon_flash.raw_mspct[["light"]])$num.exposures
```

As above for the LED lamp, we first calculate spectral fluence from a set of raw-counts spectral data using the high-level function `s_irrad_corrected()`.

```{r, fig.width=8, fig.asp=0.5}
xenon_flash.spct <-
  s_irrad_corrected(xenon_flash.raw_mspct, correction.method = MAYP11278_ylianttila.mthd)
getTimeUnit(xenon_flash.spct)
```
```{r, fig.width=8, fig.asp=0.5}
autoplot(xenon_flash.spct, range = c(315, NA))
```


```{r, fig.width=8, fig.asp=0.5}
xenon_flash.cps_spct <-
  s_irrad_corrected(xenon_flash.raw_mspct, correction.method= MAYP11278_ylianttila.mthd, return.cps = TRUE)
getTimeUnit(xenon_flash.cps_spct)
```
```{r, fig.width=8, fig.asp=0.5}
autoplot(xenon_flash.cps_spct, range = c(315, NA))
```

