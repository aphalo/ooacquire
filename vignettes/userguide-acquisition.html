<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Pedro J. Aphalo" />

<meta name="date" content="2024-08-02" />

<title>Acquisition of Spectra</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Acquisition of Spectra</h1>
<h3 class="subtitle"><code>ooacquire</code> 0.5.0</h3>
<h4 class="author">Pedro J. Aphalo</h4>
<h4 class="date">2024-08-02</h4>


<div id="TOC">
<ul>
<li><a href="#summary" id="toc-summary">Summary</a></li>
<li><a href="#introduction" id="toc-introduction">Introduction</a></li>
<li><a href="#building-this-vignette" id="toc-building-this-vignette">Building this vignette</a></li>
<li><a href="#measurement-of-light-spectra" id="toc-measurement-of-light-spectra">Measurement of light
spectra</a></li>
<li><a href="#spectral-irradiance" id="toc-spectral-irradiance">Spectral
irradiance</a>
<ul>
<li><a href="#acquiring-a-single-irradiance-spectrum" id="toc-acquiring-a-single-irradiance-spectrum">Acquiring a single
irradiance spectrum</a></li>
<li><a href="#acquiring-a-time-series-of-irradiance-spectra" id="toc-acquiring-a-time-series-of-irradiance-spectra">Acquiring a time
series of irradiance spectra</a></li>
<li><a href="#spectral-fluence" id="toc-spectral-fluence">Spectral
fluence</a></li>
<li><a href="#spectral-transmittance-absorptance-and-reflectance" id="toc-spectral-transmittance-absorptance-and-reflectance">Spectral
transmittance, absorptance and reflectance</a></li>
</ul></li>
<li><a href="#rolling-your-own" id="toc-rolling-your-own">Rolling your
own</a></li>
<li><a href="#using-scripts" id="toc-using-scripts">Using
scripts</a></li>
</ul>
</div>

<div id="summary" class="section level2">
<h2>Summary</h2>
<p>This package supports direct acquisition of spectra only from Ocean
Optics spectrometers. It also allows computations on RAW spectral counts
to be done with the spectrometer off-line. What distinguishes it from
other software is the implementation of special algorithms for
measurement protocols that enhance the signal to noise ratio by one
order of magnitude, allowing the measurement of ultraviolet-B radiation
in sunlight using array spectrometers.</p>
<ul>
<li>Allows spectral data acquisition from within an R session in near
real-time.</li>
<li>Allows conversion of raw-counts data acquired using SpectraSuite or
OceanView on PCs and possibly using the open-source SeaBreeze based
software running on the Raspberry Pi single-board microcomputer. It also
supports computations based on files acquired autonomously with the Jaz
spectrometer.</li>
<li>Irradiance, fluence, reflectance, transmittance, absorptance and
absorbance can be derived from raw spectra.</li>
<li>Measurements of both continuous and pulsed light sources is
possible.</li>
<li>Different measurement protocols, data averaging, integration time
bracketing, automatic adjustment of integration time can be used and
corrections for stray light and slit function can be applied.</li>
<li>Acquisition of time series of spectra is also possible in two
different ways: at timed intervals, or as fast as possible using
buffered transfer from the spectrometer. The minimum delay depends on
the spectrometer but can be as short as a few microseconds.</li>
<li>Data and plots are saved to files asynchronously to avoid blocking
the user interface or data acquisition.</li>
</ul>
<p>Although not directly supported by this package, the code it includes
can serve as a basis for equivalent protocols and corrections of data
acquired with software and/or spectrometers from other suppliers.</p>
</div>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>This document describes only high level functions for interactive
data acquisition. We first show simple examples of their use, assuming
that R, the needed R packages, one of Temurin 8 <strong>OpenJDK</strong>
or Oracle’s Java 8 <strong>JDK</strong> or Amazon’s Corretto Java 8
<strong>OpenJDK</strong> plus Ocean Optics’ free OmniDriver runtime are
all installed and working (see this package’s README and the README of
package ‘rOmniDriver’ for details).</p>
<p>In this vignette we provide a brief tutorial on how to carry out
measurements.</p>
<p>The User Guide menu of the <a href="https://docs.r4photobiology.info/ooacquire/">on-line
documentation</a> includes in addition to the vignettes included in the
package, two on-line only chapters: <a href="https://www.r4photobiology.info/pages/acq-irrad-tutorial.html">a
tutorial on how to measure spectral irradiance</a> with ‘oocquire’ and a
<a href="https://www.r4photobiology.info/pages/ooacquire-algorithms.html">description
of the algorithms used</a>.</p>
<p>The package exports both high level user-friendly functions and the
lower level functions used to build them. What we describe here is the
use of the higher level functions.</p>
</div>
<div id="building-this-vignette" class="section level2">
<h2>Building this vignette</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="co"># change this to TRUE to run acquisition examples</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="co"># these examples require user interaction to complete!!</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>sr.online <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span></code></pre></div>
<p><strong>NOTE:</strong> This vignette can be built even if a
spectrometer is not connected as the code chunks with code that “talks”
with the instrument are by default not evaluated. Set above
<code>sr.online &lt;- TRUE</code> and connect a spectrometer for which a
calibration is available if you intend to rebuild this vignette with
live output from a measurement session.</p>
</div>
<div id="measurement-of-light-spectra" class="section level2">
<h2>Measurement of light spectra</h2>
<p>An emission spectrum of light emitted by a source or the spectrum of
light received on a surface describes the energy or photon distribution
as a function of wavelength. A calibration describes the relationship
between the signal response of a sensor and a physical quantity. For
spectral measurements this involves a description of the response of the
spectrometer to light of each measurable wavelength and a calibration of
detector pixels or monochromator positions to true wavelengths</p>
<p>Thus to acquire spectral irradiance, a suitable instrument
calibration and correction method description should be also available
and in practice implemented in software. Advanced algorithms implemented
in ‘ooacquire’ require a special characterization of the spectrometer.
If such characterization is not available, a simpler approach, as
normally used with most other software, is also available in
‘ooacquire’. If no calibration is available in the format used by this
package, an attempt is made to retrieve calibration data from the
connected spectrometer. In most cases the wavelength calibration can be
retrieved, but the multipliers needed to compute spectral irradiance are
stored in memory only if expressly saved for this type of measurements
as a result of a calibration. An irradiance calibration is not needed to
measure quantities like spectral reflectance and transmittance that are
relative to a reference. Protocols, characterization and calibration
information can all be stored once in the special format used by
‘ooacquire’ if available. Subsequently, the acquisition of spectra does
not differ much and any differences are reflected in the user interface
as long as a calibration is available. What differs is the quality of
the spectral data that is acquired.</p>
<p>In the code chunks below we use calibrations included as part of the
package. As the serial number stored with the calibration is validated
against that retrieved from the instrument, the examples below will work
only with our own instruments, rather than with the ones you may intend
to use. In most cases you will need to either import calibration data as
provided by Ocean Optics/Ocean Insight or for more complex correction
algorithms, manually create R objects with calibration and
characterisation data obtained from other sources. Such setup needs to
be done only once, and updated when the spectrometer is
recalibrated.</p>
<p>When sunlight or radiation emitted by lamps driven by direct or
alternating current are measured the integration time can be used as
reference to compute fluxes such as energy irradiance or photon
irradiance. In the case of many lamps driven by alternating current
accurate measurements require us to consider the line frequency (50 Hz
in Europe, 60 Hz in USA) because light output will usually vary
cyclically at twice these frequencies (100 Hz or 120 Hz) making it
necessary to use integration times that are multiples of the duration of
one half cycle of line frequency (10 ms and 8.3333 ms, respectively) or
alternatively use long-enough integration times for several cycles to be
included in the measurement interval. The same considerations apply to
transmittance, reflectance, and absorptance measurements using
continuous radiation sources.</p>
<p>When measuring radiation from pulsed light sources such as xenon
flashes we express the measurements as spectral power or photons per
event (pulse or “flash”) and the integration time must simply be long
enough to encompass a known number of <em>whole</em> pulses. We use the
number of pulses to compute fluence rate per pulse or event. The same
considerations apply to transmittance, reflectance and absorptance
measurements using pulsed radiation sources.</p>
<p>During a measurement event either a single spectrum or a time series
of spectra are acquired and stored in one or two data objects, together
with metadata describing the spectrometer and settings used. By default,
both raw-counts data and the spectra expressed in physical units are
stored in two R objects. Optionally, it is possible to store only
raw-counts data in a single R object and computation of spectra
expressed in physical units done “off-line”.</p>
<p>The functions described below by default acquire for each measurement
event one or more raw-counts spectra for each spectrum expressed in
physical units. The interactive spectral-data-acquisition functions by
default compute the corresponding spectrum or spectra expressed in a
physical quantity, and save the data, both raw and computed,
asynchronously, creating one <code>.Rda</code> R-data file per
measurement event.</p>
<p>After each measurement event, the operator is by default, presented
with an annotated plot. The annotations that the user can adjust before
continuing for example choosing energy vs. photon units. The plot
corresponding to the measurement is saved to a <code>.pdf</code> file,
also before a new measurement is started. This approach to saving the
data ensures that in case of a computer failure or program crash, at
most data for a single measurement event will be lost.</p>
<p>Spectra grouped into collections can be also saved and plotted at any
time during a measurement session. When saving a collection all spectra
expressed in physical units are collected into a <code>.mspct</code>
object, and the corresponding raw-counts-spectra are collected into an R
list object. Summaries of the measurements can be computed and saved as
a <code>data.frame</code>. All these R objects are saved into a single
<code>.Rda</code> file. The summaries are in addition saved into a
<code>.csv</code> file.</p>
<p>A measurement event can consist of a single <em>“light”</em> spectrum
or of a time series of <em>“light”</em> spectra. When reference spectra
are acquired, the <em>“light”</em> spectra in a measurement event share
the <em>“dark”</em> and, if used, also the <em>“filter”</em> spectra.
The <em>“dark”</em> and <em>“filter”</em> spectra are used as references
for the conversion of <em>“light”</em> raw-counts-spectra into physical
quantities such as spectral irradiance.</p>
<p>Each raw-counts spectrum can consist in one or more scans or readings
of the detector array, taken using identical or different settings in
the spectrometer, depending on the protocol used. Once the desired
protocol is selected, the measurements can be acquired with little
intervention from the user, and the settings are retained across
successive measurement events, unless expressly modified.</p>
<p>Whether a time series of spectra or a single spectra is acquired
depends on the arguments passed to parameters of the function.</p>
<table>
<caption>Timing of the acquisition of spectra. Buffered acquisition is
as fast as the spectrometer allows, with the frequency controlled by the
total integration time plus an overhead &lt; 1 ms. In the case of
Buffered acquisition there is minimal dead time between acquisitions.
Fast acquisition has more dead time as settings in the spectrometer need
to we modified two or more times per measuring event. While Buffered and
Fast series are acquired as fast as possible, in the case of a timed
series, spectra are retrieved at specific times, with dead/waiting time
in-between.</caption>
<colgroup>
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="19%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Parameter</th>
<th align="center">Buffered</th>
<th align="center">Fast series</th>
<th align="center">Timed series</th>
<th align="center">Timed single</th>
<th align="center">Single</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">interface.mode</td>
<td align="center">“series”</td>
<td align="center">“series”</td>
<td align="center">“series”</td>
<td align="center">“series”</td>
<td align="center">“auto”/“simple”</td>
</tr>
<tr class="even">
<td align="left">step.delay</td>
<td align="center">0 s</td>
<td align="center">0 s</td>
<td align="center">&gt; 0 s</td>
<td align="center">NA</td>
<td align="center">NA</td>
</tr>
<tr class="odd">
<td align="left">start.delay</td>
<td align="center">&gt;= 0 s</td>
<td align="center">&gt;= 0 s</td>
<td align="center">&gt;= 0 s</td>
<td align="center">&gt; 0 s</td>
<td align="center">= 0 s</td>
</tr>
<tr class="even">
<td align="left">HDR</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes/no</td>
<td align="center">yes/no</td>
<td align="center">yes/no</td>
</tr>
</tbody>
</table>
<p>It is possible to select a different quantity to be saved to files by
passing an argument to <code>qty.out</code>:</p>
<ul>
<li><code>&quot;raw&quot;</code> skips computations of spectra in physical units
and saves to file only raw-counts data with metadata. In this case
conversion into physical units must be done at a later time. The
descriptor of the instrument if missing is retrieved from the
instrument.</li>
<li><code>&quot;cps&quot;</code> (default if no spectral irradiance calibration is
available) converts raw-counts into linearised counts-per-second and
saves to file both raw-counts data with metadata and counts-per second
spectral data. The descriptor of the instrument if missing is retrieved
from the instrument. Plots can be displayed on screen and are by default
saved as <code>.pdf</code> files.</li>
<li><code>&quot;irrad&quot;</code> (default if a spectral irradiance calibration
is available) converts raw-counts into corrected spectral irradiance (a
flux rate expressed per unit time) and saves to a file both raw-counts
data with metadata and spectral irradiance data. If the descriptor and
spectral irradiance calibration are not available in R but available in
the memory of the instrument they are retrieved. Plots can be displayed
on screen and are by default saved as <code>.pdf</code> files.</li>
<li><code>&quot;fluence&quot;</code> same as “irrad”`, but the quantity computed
is spectral fluence (a flux expressed per illumination event, usually
one flash per measurement).</li>
</ul>
<p>The saved data objects include metadata as attributes:</p>
<table>
<caption>Attributes of spectral objects.</caption>
<colgroup>
<col width="70%" />
<col width="10%" />
<col width="18%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">purpose</th>
<th align="center">included</th>
<th align="center">accessor</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">user comment</td>
<td align="center">optional</td>
<td align="center"><code>comment()</code></td>
</tr>
<tr class="even">
<td align="left">what was measured</td>
<td align="center">optional</td>
<td align="center"><code>what_measured()</code></td>
</tr>
<tr class="odd">
<td align="left">where was measured</td>
<td align="center">optional</td>
<td align="center"><code>where_measured()</code></td>
</tr>
<tr class="even">
<td align="left">when was measured in UTC time</td>
<td align="center">automatic</td>
<td align="center"><code>when_measured()</code></td>
</tr>
<tr class="odd">
<td align="left">simply how was measured</td>
<td align="center">automatic</td>
<td align="center"><code>how_measured()</code></td>
</tr>
<tr class="even">
<td align="left">instrument descriptor including calibration, serial
number, configuration</td>
<td align="center">automatic</td>
<td align="center"></td>
</tr>
<tr class="odd">
<td align="left">instrument settings used</td>
<td align="center">automatic</td>
<td align="center"></td>
</tr>
</tbody>
</table>
<p>The attributes in the last two rows of the table, together with
always saving raw-counts spectra to files, allows recalculation of
physical quantities and provides a built-in trace of the origin of the
data.</p>
</div>
<div id="spectral-irradiance" class="section level2">
<h2>Spectral irradiance</h2>
<p>Spectral energy irradiance (<span class="math inline">\(W m^{-2}
nm^{-1}\)</span>) and spectral photon irradiance (<span class="math inline">\(mol s^{-1} m^{m-2} nm^{-1}\)</span>$) are fluxes
expressed as energy or quanta, respectively per unit area of a receiving
surface. They can be inter-converted and there is no difference in how
they are measured or a need for different calibration.</p>
<p>After loading the package as shown in the section below and
connecting a spectrometer by USB, calling function
<code>acq_irrad_interactive()</code> opens a connection to the
spectrometer and starts an interactive spectral-data acquisition
session. The function takes several arguments, which have as defaults
the most frequently used values. However, frequently, users will want to
pass arguments in the call to set the interface mode.</p>
<p>Of the formal parameters of function
<code>acq_irrad_interactive()</code>, <code>interface.mode</code>
selects which settings can be controlled interactively during a session,
i.e., which settings can be modified by the user at run time (in other
words, it alters which options are visible or not in menus as well as
some of the default settings). The simplified interfaces make
measurements simpler and faster in specific situations, while the
defaults for the session can always be changed by passing arguments when
calling function <code>acq_irrad_interactive()</code>. The default
<code>interface.mode = &quot;auto&quot;</code> retains the behaviour of earlier
versions of package ‘ooacquire’, but
<code>interface.mode = &quot;simple&quot;</code> gives access to all the
parameters that need to be set at runtime for some common measurements.
Modes <code>&quot;manual&quot;</code> and <code>&quot;full&quot;</code> make it possible to
manually set the integration time, retaining the ability to
automatically adjust it on demand. Mode “fluence” makes the interface
suitable for the measurement of pulsed light sources and “series” makes
it possible to acquire time series of spectra as a single measurement
event. Variations of the modes ending in <code>.attr</code> enable the
user interface for entering for each measurement event the texts to be
stored in attributes <code>comment</code> and
<code>what.measured</code>.</p>
<table style="width:100%;">
<caption>Interface modes for acquisition of non-timed single spectra per
measurement event.</caption>
<colgroup>
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Parameter</th>
<th align="center">Single</th>
<th align="center">Single</th>
<th align="center">Single</th>
<th align="center">Single</th>
<th align="center">Single</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">interface.mode</td>
<td align="center">“auto”</td>
<td align="center">“simple”</td>
<td align="center">“full”</td>
<td align="center">“manual”</td>
<td align="center">“fluence”</td>
</tr>
<tr class="even">
<td align="left">step.delay</td>
<td align="center">NA</td>
<td align="center">NA</td>
<td align="center">NA</td>
<td align="center">NA</td>
<td align="center">NA</td>
</tr>
<tr class="odd">
<td align="left">start.delay</td>
<td align="center">NA</td>
<td align="center">NA</td>
<td align="center">NA</td>
<td align="center">NA</td>
<td align="center">NA</td>
</tr>
<tr class="even">
<td align="left">HDR</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">(yes)</td>
</tr>
<tr class="odd">
<td align="left">target.margin</td>
<td align="center">yes</td>
<td align="center">fixed</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr class="even">
<td align="left">default integ.</td>
<td align="center"><em>tune</em></td>
<td align="center"><em>tune</em></td>
<td align="center"><em>tune</em></td>
<td align="center"><em>user-set</em></td>
<td align="center"><em>user-set</em></td>
</tr>
</tbody>
</table>
<table>
<caption>Interface modes for acquisition of time series of spectra and
timed single spectra per measurement event.</caption>
<colgroup>
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
<col width="20%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Parameter</th>
<th align="center">Buffered</th>
<th align="center">Fast series</th>
<th align="center">Timed series</th>
<th align="center">Timed single</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">interface.mode</td>
<td align="center">“series”</td>
<td align="center">“series”</td>
<td align="center">“series”</td>
<td align="center">“series”</td>
</tr>
<tr class="even">
<td align="left">step.delay</td>
<td align="center">0 s</td>
<td align="center">0 s</td>
<td align="center">&gt; 0 s</td>
<td align="center">NA</td>
</tr>
<tr class="odd">
<td align="left">start.delay</td>
<td align="center">&gt;= 0 s</td>
<td align="center">&gt;= 0 s</td>
<td align="center">&gt;= 0 s</td>
<td align="center">&gt; 0 s</td>
</tr>
<tr class="even">
<td align="left">HDR</td>
<td align="center">no</td>
<td align="center">yes</td>
<td align="center">yes/no</td>
<td align="center">yes/no</td>
</tr>
<tr class="odd">
<td align="left">target.margin</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
<tr class="even">
<td align="left">default integ.</td>
<td align="center"><em>tune</em></td>
<td align="center"><em>tune</em></td>
<td align="center"><em>tune</em></td>
<td align="center"><em>tune</em></td>
</tr>
</tbody>
</table>
<p>The <code>correction.method</code> and <code>descriptor</code>
parameters are used to pass the calibration and protocol information
specific to a given spectrometer. For spectrometers “known” to package
‘ooacquire’ these also have suitable defaults which are selected after
retrieving from the spectrometer its serial number. These parameters are
not totally redundant as for a given spectrometer multiple correction
algorithms, and/or calibrations for different entrance optics, may be
available and selected by overriding the defaults. In all cases these
arguments are checked to match the serial number of the attached
spectrometer, and rejected in cases of mismatch.</p>
<p>If no calibration information is available based on the serial number
or the user has not supplied valid calibration information as arguments
to the call, an attempt is made to retrieve an iradiance calibration
from the spectrometer EEPROM. Because of the way in which irradiance
calibrations are stored in Ocean Optics spectrometers. Calibration data
retrieved from the EEPROM can only be used if the user provides
information about the diffuser used as entrance optics and the retrieved
calibration is valid, thus among other things, done using the same
optical fibre as being used for the measurements. If a calibration
cannot be retrieved from the EEPROM or information about the diffuser is
not supplied, this last attempt also fails. In this case the function
falls back into a mode that returns counts-per-second instead of
spectral irradiance, with a warning. A wavelength calibration remains as
a requirement but it can be usually retrieved from the spectrometer
EEPROM.</p>
<p>Saving of plots as PDF files is controlled through a
<code>logical</code> argument passed to parameter
<code>save.pdfs</code>. In the case of saving of collections of spectra
and summaries, passing <code>FALSE</code> to <code>save.summaries</code>
and <code>save.collections</code> disables the user interface for their
creation.</p>
<p>Arguments passed to other formal parameters only alter the starting
default values presented interactively to the user.</p>
<div id="acquiring-a-single-irradiance-spectrum" class="section level3">
<h3>Acquiring a single irradiance spectrum</h3>
<div id="a-simple-example" class="section level4">
<h4>A simple example</h4>
<p>Assuming a calibration is available the minimal steps to measure
spectral irradiance are as follows.</p>
<ol start="0" style="list-style-type: decimal">
<li><p>(See the README files of R packages <a href="https://docs.r4photobiology.info/ooacquire/">‘ooacquire’</a> and
<a href="https://docs.r4photobiology.info/rOmniDriver/">‘rOmnidriver’</a>
for software installation instructions).</p></li>
<li><p>Start R and load the package.</p></li>
</ol>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a><span class="fu">library</span>(ooacquire)</span></code></pre></div>
<ol start="2" style="list-style-type: decimal">
<li><p>Connect an Ocean Optics spectrometer to a USB port. To avoid
problems use a short and high quality USB cable, if this is not possible
use an active USB extension cable. In all cases use a short and known
good USB cable when using ‘ooacquire’ or a given spectrometer for the
first time and later keep this short and good USB cable always at hand
to debug any possible USB connection problems if they happen.</p></li>
<li><p>Start an interactive measuring session, in this example accepting
all defaults except for the choice of a simplified user
interface.</p></li>
</ol>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">acq_irrad_interactive</span>(<span class="at">interface.mode =</span> <span class="st">&quot;simple&quot;</span>)</span></code></pre></div>
<p>If everything works as expected, the version of OmniDriver that has
been found will be reported. If one or more spectrometers are found,
they will be listed with their serial numbers for the user to choose one
of them. Once a connection and software are initialized data acquisition
is possible.</p>
<ol start="4" style="list-style-type: decimal">
<li>Follow the prompts to acquire spectra.</li>
</ol>
<p>Many settings can be adjusted during a data acquisition session.
Here, using <code>interface.mode = &quot;simple&quot;</code> fewer of these
settings can be modofied interactively than when using, for example,
<code>interface.mode = &quot;full&quot;</code>, which has additional menu options
in the user interface. If one knows in advance what settings will need,
these can be passed as arguments when starting the session by calling
<code>acq_irrad_interactive()</code>. The values passed as arguments
become the new defaults or fixed depending on the
<code>interface.mode</code>.</p>
<p>In most cases when values supplied by the user fall outside those
accepted by the connected instrument, these values are adjusted to the
nearest valid value. In the remaining cases a new value is requested
with a message.</p>
<p>We can pass the objects containing the correction method definition
and the instrument descriptor that includes the calibration data as
arguments.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">acq_irrad_interactive</span>(<span class="at">correction.method =</span> ooacquire<span class="sc">::</span>MAYP11278_ylianttila.mthd,</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>                      <span class="at">descriptors =</span> ooacquire<span class="sc">::</span>MAYP11278_descriptors)</span></code></pre></div>
<p>In this case, this corresponds to a spectrometer whose data are
available in the package and recognized automatically. Thus is
equivalent to accepting all defaults as below. The defaults are dynamic,
based on the serial number of the spectrometer unit that is
attached.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a><span class="fu">acq_irrad_interactive</span>()</span></code></pre></div>
<p>However, for this spectrometer additional correction methods are
available. Two calibrations with different entrance optics are
available, and can be selected by means of an argument passed to
parameter <code>entrance.optics</code>.</p>
<p>In the case of calibrations done by Ocean Insight or with their
software, and retrieved from the spectrometer EEPROM we need to pass an
argument to parameter <code>area</code> indicating the effective area of
the diffuser, or the name of one of the entrance optics known to
‘ooacquire’.</p>
<p>Although we discuss settings as arguments to formal parameters of
function <code>acq_irrad_interactive()</code>, the settings discussed
below can be also set interactively by the user, at least in one of the
supported interface modes. The functions described here, except when in
interface mode <code>&quot;manual&quot;</code>, will set a suitable integration
time automatically.</p>
</div>
<div id="protocols-for-enhanced-performance" class="section level4">
<h4>Protocols for enhanced performance</h4>
<p>Dynamic range is the difference between the smallest and largest
values that can be detected in a measurement. Noise is the component of
the measured value that is not a reflection of what we want to measure.
An array detector not only responds to light, but it is also to a small
extent excited also by thermal radiation, electrical fields and even
cosmic particles. These events are infrequent and so during a single
integration are likely to affect only individual pixels and different
pixels in different integrations. A further problem is stray light,
photons that imping on the “wrong” pixel because of internal reflections
in the optical bench of the spectrometer. Different protocols and
correction algorithms can mitigate the effect of these problems on the
quality of the spectral data.</p>
<p>If we use a single value for integration time (the equivalent of
exposure time in a photographic camera) the realized dynamic range is
the intrinsic dynamic range of the array detector and electronics of the
spectrometer. In this case we pass a single numeric value as argument to
<code>HDR.mult</code> to indicate acquisition using a single integration
time. Except in very unusual cases, we use 1, because
<code>HDR.mult</code> is a multiplicative factor applied to the optimal
integration time.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="fu">acq_irrad_interactive</span>(<span class="at">HDR.mult =</span> <span class="dv">1</span>,</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>                      <span class="at">tot.time.range =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="cn">Inf</span>))</span></code></pre></div>
<p>Averaging of multiple “scans” mitigates “random” noise because the
longer the total measurement time the most likely it is that all pixels
are similarly affected by the noise. The noise is still present, but it
affects more evenly the different pixels. The approach used in
<code>acq_irrad_interactive()</code> is for the user to supply an upper
and lower limit to the sum of integration times from multiple scans and
the software determines the number of scans that are needed at the time
the optimal integration time is tuned. Keeping the
<code>tot.time.range</code> approximately constant can help keep the
noise levels consistent across multiple measurement events.</p>
<p>The argument passed to <code>tot.time.range</code>, a vector of one
or two numbers, indicates the allowed range for the sum of the
integration times in seconds per spectrum acquired. If two identical
numbers or a single number are passed, this exact time is used.</p>
<p>The integration time for individual scans can be adjusted
automatically to ensure good performance of the instrument and used to
compute the number of scans to average. The maximum and minimum
integration times supported by the spectrometer hardware set the
effective limits for the integration time. The smallest argument
accepted for <code>tot.time.range</code> is zero and the largest
<code>Inf</code>. Setting <code>tot.time.range = c(0, Inf)</code> as in
the example above ensures that only one integration per measurement will
be used, and that the integration times used will be from the whole
range the spectrometer supports.</p>
<p>It is possible to use in a call to
<code>acq_irrad_interactive()</code> a value larger than one for
<code>HDR.mult</code> even when a single integration time is used. This
is unusual, but if we want to increase the raw-counts in a low-signal
region, by forcing clipping in a different region of spectrum this is an
alternative approach to manually setting the integration time to a value
given in seconds.</p>
<p>The dynamic range in the spectral data can be increased by splicing
spectra measured using increasing integration times (similar to
“exposure bracketing” as used in photography followed by merging to
ensure enough detail is captured in both shade and highlights). In most
cases for this to significantly improve the quality of the spectral data
we also need to average data from several successive integrations to
control the noise. The defaults in <code>acq_irrad_interactive()</code>
are thus to use the optimal integration time an integration time ten
times longer and to keep the total measuring time, the sum of multiple
integration events, between 5 and 10 s.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">acq_irrad_interactive</span>(<span class="at">HDR.mult =</span> <span class="fu">c</span>(<span class="at">short =</span> <span class="dv">1</span>, <span class="at">long =</span> <span class="dv">10</span>), <span class="co"># the default</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>                      <span class="at">tot.time.range =</span> <span class="fu">c</span>(<span class="dv">5</span>, <span class="dv">15</span>), <span class="co"># the default</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>                      <span class="at">correction.method =</span> ooacquire<span class="sc">::</span>MAYP11278_ylianttila.mthd,</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>                      <span class="at">descriptors =</span> ooacquire<span class="sc">::</span>MAYP11278_descriptors)</span></code></pre></div>
<p>The resulting spectra are merged choosing the <em>most suitable</em>
of the used integration times for each wavelength region. Usually using
two integration times with 1 and 10 as <code>HDR.mult</code> is a good
compromise. However, there is no built-in limitation in the package
code, making it possible to use a vector of two, three, four or more
values, which combined with a very long total acquisition time of the
order of minutes, can yield very good control of noise for light sources
with stable output. Consequently, although the default setting
<code>HDR.mult = c(1, 10)</code> tends to work well, settings like
<code>HDR.mult = c(1, 5, 25)</code> may be useful in special
circumstances.</p>
<p>We next set total acquisition time to a fixed length of 10 seconds.
Once this setting is active, each time the integration time is
automatically set, both the integration time and number of scans are
adjusted so that total acquisition time is exactly 10 seconds, for both
short and long integration times.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">acq_irrad_interactive</span>(<span class="at">HDR.mult =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">10</span>),</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>                      <span class="at">tot.time.range =</span> <span class="dv">10</span>)</span></code></pre></div>
<p>If long integration times are needed, the setting above may result in
the use of suboptimal integration times, as the desired integration time
may have be to be shortened until it becomes an exact fraction of the
total acquisition time. To avoid this, we can supply instead of a single
fixed value for the total acquisition time, a range of values.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">acq_irrad_interactive</span>(<span class="at">HDR.mult =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">10</span>), </span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>                      <span class="at">tot.time.range =</span> <span class="fu">c</span>(<span class="dv">10</span>, <span class="dv">20</span>))</span></code></pre></div>
<p>Sometimes we may want to avoid long integration times even at the
cost of not using the whole dynamic range of the detector. For example,
when following some fast kinetics, we would usually need the integration
time not to exceed a certain time, say 50 milliseconds, we would simply
use smaller values, such as
<code>tot.time.range = c(0.03, 0.05)</code>.</p>
<p>When the integration time for individual scans is adjusted
automatically the target value of maximum instrument counts is computed
proportionally to the maximum counts specification of the spectrometer.
The head-room as a fraction of one can be set by the user as depending
on the stability or not of the irradiance we need more or less head-room
to accomodate increases in irradiance. Parameter
<code>target.margin</code> allows the user to set a <em>safety
margin</em> different from the default of 0.1 (or 10%). The example
below could help prevent clipping in cases when irradiance changes so
fast that it could be up to 25% higher during actual measurement than
during the most recent tuning of the integration time.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="fu">acq_irrad_interactive</span>(<span class="at">target.margin =</span> <span class="fl">0.25</span>)</span></code></pre></div>
<p>Although above we described the use of <code>HDR.mult</code> as a
step in splicing spectra, it is also possible at a later time also the
discard spectra acquired using specific multipliers and recalculate the
irradiance from selected raw-counts spectra. In some cases with
extremely variable light levels when acquiring time series of spectra,
it can be wise to use a rather wide range of values in the vector passed
to <code>HDR.mult</code>, which also accepts values smaller than one,
achieving a similar effect as <code>target.margin</code>
(<code>target.margin = 0.25</code> is equivalent to
<code>HDR.mult = 0.75</code>).</p>
<p>The automatic tuning step can be also skipped. For example the value
used in the previous measurement event can be reused, or the duration
set manually by the user.</p>
<p>None of the approaches described above can control stray light caused
by reflections in the optical bench. Correction for stray light in the
case of some spectrometers makes it necessary to measure it using a
short pass filter. The function also supports this type of protocols
with two references, and uses it for spectrometers for which special
characterization is available, to allow the measurement of UV-B
radiation in sunlight.</p>
</div>
</div>
<div id="acquiring-a-time-series-of-irradiance-spectra" class="section level3">
<h3>Acquiring a time series of irradiance spectra</h3>
<p>Measuring a time series of irradiance spectra using the approaches
described above can be difficult. Triggering acquisition of spectra at
regular intervals manually is difficult for long time steps and
impossible for very short ones. In most cases we also need to measure
many light spectra for each “dark” reference measurement. Interface mode
<code>&quot;series&quot;</code> introduced in version 0.3.0 of ‘ooacquire’ and
enhanced in later versions targets this type of measurements.</p>
<p>For measuring a time series, we pass
<code>interface.mode = &quot;series&quot;</code> in the call to
<code>acq_irrad_interactive()</code>. We can set the default parameters
for the series through arguments. The following example sets the default
for a series with measuring events triggered at the start of each
minute, with 60 s time step between successive <code>&quot;light&quot;</code>
spectra and 60 spectra, for a total time expanse of 1 h. We also set the
initial delay to zero, so that once we start the light measurement event
by pressing enter, the acquisition of the time series starts at the
beginning of the next minute.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">acq_irrad_interactive</span>(<span class="at">interface.mode =</span> <span class="st">&quot;series&quot;</span>,</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>                      <span class="at">seq.settings =</span> <span class="fu">list</span>(<span class="at">start.boundary =</span> <span class="st">&quot;minute&quot;</span>,</span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>                                          <span class="at">initial.delay =</span> <span class="dv">0</span>, <span class="co"># seconds</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>                                          <span class="at">step.delay =</span> <span class="dv">60</span>, <span class="co"># seconds</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>                                          <span class="at">num.steps =</span> <span class="dv">60</span>))</span></code></pre></div>
<p>More realistically, we would set some other defaults. The example
below has worked well in sunlight.</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="fu">acq_irrad_interactive</span>(<span class="at">interface.mode =</span> <span class="st">&quot;series&quot;</span>,</span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>                      <span class="at">tot.time.range =</span> <span class="fu">c</span>(<span class="dv">5</span>, <span class="dv">10</span>),</span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>                      <span class="at">target.margin =</span> <span class="fl">0.1</span>,</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>                      <span class="at">qty.out =</span> <span class="st">&quot;irrad&quot;</span>,</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>                      <span class="at">HDR.mult =</span> <span class="fu">c</span>(<span class="fl">0.3</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">10</span>),</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>                      <span class="at">seq.settings =</span> <span class="fu">list</span>(<span class="at">start.boundary =</span> <span class="st">&quot;minute&quot;</span>,</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>                                          <span class="at">initial.delay =</span> <span class="dv">0</span>,</span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>                                          <span class="at">step.delay =</span> <span class="dv">60</span>,</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>                                          <span class="at">num.steps =</span> <span class="dv">60</span>))</span></code></pre></div>
<p>That the acquisition of spectra is continuously running in the
spectrometer is something to be aware of, because it means that this is
what determines the true time step between successively retrieved
spectra and that, say using a <code>step.delay</code> that is not a
multiple of the frequency at which the spectrometer is acquiring the
spectra will result only in missing the retrieval of some of the spectra
measured by the spectrometer, but not in a different effective time
step! In other words with short time steps we need to be aware that new
spectra are acquired at time steps that are a multiple of the
<strong>integration time</strong> setting of the spectrometer plus some
small overhead that depends on the model of the spectrometer. This is
tricky as the length of the integration time needs to be adjusted based
on irradiance. The problem barely exists if we average multiple spectra
during a measurement, or the time step includes some idle time between
acquisitions.</p>
<p>The OmniDriver API contains special functions for acquisition of
spectra at high speed. These functions store the spectra in a computer
memory buffer for later retrieval by user code, minimizing the overhead,
but they do not allow control over the timing of successively acquired
spectra. The <code>&quot;series&quot;</code> mode uses them only for
<code>step.delay = 0</code> if no HDR integration time bracketing is
used. In all other cases normal API functions are used so as to allow
the use of HDR bracketing or the choice of the time step between
successive acquisitions of spectra. Because, of how OO array
spectrometers work, some limitations exist. When using
<code>step.delay = 0</code> the time step is controlled by the length of
the measurement, or the integration time if spectra are not averaged for
each measurement.</p>
<p>In my test with a specific PC under Windows 10 together with a
USB2000 spectrometer and without bracketing I was able to use a minimum
<code>step.delay = 0.052</code> with <code>tot.time.range = 0.050</code>
with <code>HDR.mult = 1</code>. From these tests I infer that the
USB2000 spectrometer is constantly measuring spectra with an overhead of
<span class="math inline">\(2\,ms\)</span> (this delay is even shorter
in modern spectrometer models) and that the overhead incurred by
‘ooacquire’ in reading a spectrum is less than 50 ms.</p>
<p>In the memory buffered mode with a Maya 2000 Pro I was able to
measure using an integration time of <span class="math inline">\(7.2\,ms\)</span> a series with a median time step
of less than 7.23 ms or an overhead of less than <span class="math inline">\(30\,\mu s\)</span>. However, I observed some small
variation in the length of successive time step across a series. Anyway
time stamps are saved with a resolution of <span class="math inline">\(1\,\mu s\)</span>.</p>
<p><strong>The time overhead depends on the spectrometer, the PC and
most likely the operating system and possibly the version of OmniDriver,
Java, R and ‘ooacquire’. Consequently before attempting measurements
using <code>step.delay</code> values that are not much longer than the
largest value in the vector passed to <code>tot.time.range</code>, some
experimentation will be needed. The package attempts to detect
<code>step.delay</code> values that are too short to be achieved and
overrides them with <code>step.delay = 0</code></strong>.</p>
<p>When using HDR-integration-time bracketing, the spectrometer is not
free running or continuously acquiring spectra. Settings need to be
changed, acquisition of spectra restarted and the spectral data
subsequently acquired only after a freshly measured spectrum is
available. This adds a lot of overhead compared to retrieving spectra
that are being measured by the spectrometer using multitasking while the
PC is busy with other tasks, such as retrieving the previous spectrum.
Furthermore, this also means that when using HDR bracketing, the
overhead depends on the <code>tot.time.range</code> and
<code>HDR.mult</code> settings and on the integration time. In contrast,
when the settings are not modified between successively acquired spectra
the overhead is much less and less dependent on the integration time and
arguments passed to other parameters.</p>
<p>So with care about choosing matching integration times and
<code>step.delay</code> values without HDR bracketing one can achieve as
little as 50 ms between acquired spectra at timed steps. However, when
using HDR bracketing, a rough guide is that the minimum time step that
can be achieved is about twice the sum of the summed integration time
values used. When <code>tot.time.range</code> is set as a range, then
the longest time should be considered as limiting.</p>
<p>The high speed acquisition mode retrieves as quickly as possible the
spectra as they are acquired, and the time step is simply the
integration time plus the spectrometer overhead. To enable this mode we
use <code>step.delay = 0</code>. The time stamp used for spectra in
‘ooacquire’ until version 0.3.0 has been the time when spectra are
retrieved from the spectrometer. This is close enough for most
individual measurements and series with time steps of several seconds,
but when dealing with fast time series this can be inadequate. If
<code>step.delay = 0</code> is used, the time for the first spectrum is
set when the retrieval into the memory buffer is started, but the times
for the later spectra are set based on time differences computed from
time stamps retrieved from OmniDriver. The theoretical time resolution
is better than a microsecond for objects of R’s class
<code>POSIXct</code>, and this class is used in package ‘photobiology’
to record acquisition times.</p>
<hr />
<p><strong>Measurement of series of spectra with single dark and filter
measurements makes it imperative that the functioning of the
spectrometer is stable. Consequently, when measuring series, specially
if they are longer than a few seconds, do make sure that the temperature
of the spectrometer has stabilized and that it remains stable throughout
the acquisition of the series. For example, protect the spectrometer
from direct sunlight or other sources of energy that can increase its
temperature, while allowing ventilation to allow the dissipation of the
heat generated by the spectrometer itself. Of course, active temperature
control is the best approach. Passive temperature equalization can take
30 to 45 min if the difference between the storage temperature and the
temperature under which the spectrometer is used is large (e.g., more
than 10 C).</strong></p>
<p><strong>As the spectrometer electronics dissipate energy, even when
used at the same temperature at which it was stored, the spectrometer
should be allowed to warm up for 10 to 20 minutes before attempting to
measure a time series. Although allowing the spectrometer to warm up for
several minutes is always beneficial, when a single reference dark
measurement is used for a series of light measurements, it is crucial
that the dark reference is not invalidated by changes in the temperature
of the spectrometer.</strong></p>
<hr />
</div>
<div id="spectral-fluence" class="section level3">
<h3>Spectral fluence</h3>
<p>Function <code>acq_irrad_interactive()</code> has replaced function
<code>acq_fluence_interactive</code>. Fluence spectra are returned by
<code>acq_irrad_interactive()</code> when
<code>qty.out = &quot;fluence&quot;</code>. Some of the defaults for other
parameters also change. Otherwise all the functionality described above
for irradiance measurements is available except the
<code>&quot;series&quot;</code> interface mode.</p>
<p>If the duration of the exposure to a continuous light source is
known, then spectral irradiance multiplied by this time duration gives
spectral fluence, and can be obtained by measuring spectral irradiance
as described in the previous section. In this section we discuss the
case when spectral fluence is measured directly, using an integration
time that encompasses the whole duration of the irradiation event,
especially when the duration of this event is unknown or spectral
irradiance varies through the irradiation event and we are interested in
the accumulated exposure or “dose”.</p>
<p>Fluence, also called radiant exposure, is defined per exposure event
rather than per unit time. When measuring pulsed light sources, the
length of exposure is determined by the duration of the pulse, which is
usually not known with precision. In the discussion below we assume that
the quantity of interest is fluence per pulse. For this type of
measurements the integration time setting in the spectrometer only
affects the window within which pulses will be measured, consequently,
it is always set manually. The way of controlling the number of photons
reaching the detector during an integration is through the number of
pulses per integration and/or the fluence provided by each pulse (e.g.,
by altering the distance between source and instrument entrance optics
or the power settings of the source).</p>
<p>We start the session as described above for irradiance, but using
function <code>acq_fluence_interactive()</code>. Using defaults except
for <code>qty.out</code>.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">acq_irrad_interactive</span>(<span class="at">qty.out =</span> <span class="st">&quot;fluence&quot;</span>)</span></code></pre></div>
<p>The integration time can be set when calling the function to start a
session or later interactively.</p>
<p>Another important parameter is the number of exposure events. This
determines how the resulting data are expressed. If we consider that
each individual pulse is an exposure event, and for example, we trigger
five flashes per spectrometer integration (or “scan”), we would set
<code>num.exposures = 5</code>.</p>
<p>By default the user is prompted to manually trigger a pulse. However,
when triggering of pulses can be automated, a function accepting
arguments for number of pulses to parameter <code>n</code> (the number
of pulses), a delay in seconds to <code>delay</code> and a pulse length
in seconds to <code>duration</code> can be passed as argument to
parameter <code>f.trigger.on</code>. Of these currently only
<code>n</code> is implemented, and for future compatibility arguments
for <code>delay</code> and <code>duration</code> must be accepted, and
possibly ignored. <strong>It is important to be aware that multitasking
if used, must be implemented in the function passed as argument. For
automation, the pulse trigger function should return to the caller
before the pulses are triggered and the train of pulses start with
enough delay for the integration to be started before them. This can be
implemented in R code using package ‘mirai’ or as a delay implemented in
the hardware or software used to trigger the flash of light in the
source.</strong></p>
</div>
<div id="spectral-transmittance-absorptance-and-reflectance" class="section level3">
<h3>Spectral transmittance, absorptance and reflectance</h3>
<p><strong>All features available in
<code>acq_irrad_interactive()</code> have now been implemented in
function <code>acq_fraction_interactive()</code>. This means that series
of spectra can be acquired to measure the dynamics of chemical reactions
and repeats can be used to measure several samples reusing the same dark
and reference spectra. It is also possible to use the HDR feature to
improve the noise to signal ratio. Trigger functions work as in
<code>acq_irrad_interactive()</code>.</strong></p>
<p>A single function can be used for the acquisition of data where the
quantities of interest are expressed relative to a reference. This is
the case for transmittance, reflectance and absorptance. The same
parameters as discussed for <code>acq_irrad_interactive()</code> are
available in function <code>acq_fraction_interactive()</code>. We will
here describe three additional parameters only present in this function.
The first one is <code>ref.value</code> which needs to be supplied if
the reference target is imperfect, such as a white reference patch which
reflects less than 100%. The default is <code>ref.value = 1</code>, but
this parameter not only accepts numeric values as argument but also
transmittance or reflectance spectra for the target used as reference.
Consequently if the reflectance of an “imperfect” reference is know,
such reference can be used. (e.g. In the case of measuring the
reflectance of very dark objects, it might be convenient to use a grey
reference instead of a white reference). For a reference with 97%
reflectance across the whole range of wavelengths of interest one would
use.</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">acq_fraction_interactive</span>(<span class="at">ref.value =</span> <span class="fl">0.97</span>)</span></code></pre></div>
<p>Parameters <code>qty.out</code> and <code>type</code> determine the
class of object and the quantity stored in the returned objects. If the
optical set-up used is for measuring specular spectral reflectance, we
use the following code. This information will also be used when plotting
the data.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a><span class="fu">acq_fraction_interactive</span>(<span class="at">qty.out =</span> <span class="st">&quot;Rfr&quot;</span>, <span class="at">type =</span> <span class="st">&quot;specular&quot;</span>)</span></code></pre></div>
<p>Wen using <em>light sources with pulsed emission</em> we start a
session by calling function
<code>acq_fraction_pulsed_interactive()</code> instead of
<code>acq_fraction_interactive</code> and we set manually the
integration time as when measuring spectral fluence. In other respects
the procedure is similar to that for continuous light sources except for
the need to either manually or automatically trigger the light
pulses.</p>
</div>
</div>
<div id="rolling-your-own" class="section level2">
<h2>Rolling your own</h2>
<p>The functions for interactive acquisition of spectral data described
above, although useful in many cases, are meant also as examples. In
cases of routine measurements one could simplify menus by removing
entries that are not needed, or even converting the functions to
non-interactive, and possibly enhancing support for scheduled sequences
of spectral data acquisitions. This should be fairly simple, not
requiring advanced knowledge of the R language as we export lower level
functions that can be used as building blocks for new variations. It
should be even possible to use these functions to develop a user
interface based of package ‘shinny’.</p>
</div>
<div id="using-scripts" class="section level2">
<h2>Using scripts</h2>
<p>It is also possibly to combine lower level functions using R scripts
instead of through writing higher level R functions that call them.
Several example scripts are included with the package, including scripts
based on low level functions and scripts that demonstrate different ways
of using the interactive functions, including in combination with
trigger functions.</p>
<p>I recommend that you open these example scripts, and save them to
your own working directory before sourcing them or editing them.</p>
<p>You will need first to locate where in your computer’s file system
the ‘ooacquire’ package is installed, and where the file you are
interested in is, and to copy it to your own workspace. Here we copy the
script called <code>&quot;irrad-acq-interac.R&quot;</code>.</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>filepath <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;example-scripts&quot;</span>, <span class="st">&quot;irrad-acq-interac.R&quot;</span>, <span class="at">package=</span><span class="st">&quot;ooacquire&quot;</span>)</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a><span class="fu">file.copy</span>(<span class="at">from =</span> filepath, <span class="at">to =</span> <span class="st">&quot;.&quot;</span>)</span></code></pre></div>
<p>Here we copy all the example scripts.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>folderpath <span class="ot">&lt;-</span> <span class="fu">system.file</span>(<span class="st">&quot;example-scripts&quot;</span>, <span class="at">package=</span><span class="st">&quot;ooacquire&quot;</span>)</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a><span class="fu">list.files</span>(<span class="at">path =</span> folderpath, <span class="at">pattern =</span> <span class="st">&quot;.*[.]R&quot;</span>)</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a><span class="fu">file.copy</span>(<span class="at">from =</span> <span class="fu">list.files</span>(<span class="at">path =</span> folderpath, <span class="at">pattern =</span> <span class="st">&quot;.*[.]R&quot;</span>, <span class="at">full.names =</span> <span class="cn">TRUE</span>), <span class="at">to =</span> <span class="st">&quot;.&quot;</span>)</span></code></pre></div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
