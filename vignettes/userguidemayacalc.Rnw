%\VignetteEngine{knitr}
%\VignetteIndexEntry{MayaCalc User Guide}
%\VignetteDepends{knitr, MayaCalc, ggplot2, photobiology, photobiologygg, photobiologyWavebands}
%\VignetteKeyword{misc}

\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{abbrev}
\usepackage[unicode=true,pdfusetitle,
 bookmarks=true,bookmarksnumbered=true,bookmarksopen=true,bookmarksopenlevel=2,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=false]
 {hyperref}
\usepackage{listings}
\usepackage{booktabs}

<<setup, include=FALSE, cache=FALSE>>=
library(knitr)
opts_chunk$set(fig.path='figure/pos-', fig.align='center', fig.show='hold', size="footnotesize", cache=FALSE, fig.width=7, fig.height=4, out.width='.95\\textwidth', warning=FALSE)
@

<<example-0-hidden, eval=TRUE, include=FALSE>>=
library(MayaCalc)
library(ggplot2)
library(photobiology)
library(photobiologyWavebands)
library(photobiologygg)
@

<<own-set-up, echo=FALSE, include=FALSE>>=
# my_method <- "sun"
# maya_include <- FALSE
my_version <- packageVersion("MayaCalc")
@

\begin{document}

\title{MayaCalc Version \Sexpr{my_version}\\User Guide}
\author{Pedro J. Aphalo}

\maketitle

\section{Installation and use}

The functions in the package \texttt{MayaCalc} are
made available by installing the package \verb!MayaCalc! (once) and
loading it from the library when needed.

To load the package into the workspace we use \verb!library(MayaCalc)!.

<<example-0, eval=FALSE, echo=FALSE>>=
library(MayaCalc)
library(ggplot2)
library(photobiology)
library(photobiologyWavebands)
library(photobiologygg)
@

\section{Applying a calibration}

Either output files from SpectraSuite, the commercial software from Ocean Optics, or data acquired
by means of R package \texttt{MayaControl} can be used. In this user guide we use some files
from SpectraSuite, but saved as raw counts, and with not dark noise correction.

Depending on the light source and signal-to-noise ratio needed for a particular application,
different protocols can be used during measurement. This package supportsthe following protocols:

\begin{description}
\item[Ordinary] ``short" measurement reading + ``short" dark reading.
\item[Dark-noise corrrected] ``short" measurement reading + ``short" dark reading + ``short'' UV-filter reading.
\item[HDR]  ``short" measurement reading + ``short" dark reading + ` ``long" measurement reading + ``long" dark reading.
\item[HDR dark-noise corrrected ]  ``short" measurement reading + ``short" dark reading + ``long" measurement reading + ``long" dark reading + ``long'' UV-filter reading.
\end{description}

`Bracketing' or HDR is used when data from measurements with two different integration times are done. Bracketing increases the dynamic range, as the software splices such measurements, using the counts from the longer integration times for the UV region of the spectrum. A rule-of-thumb for the ``long'' measurements is to use an integration time about 10 times the ``short'' integration time.

Supplying measurements with a long pass filter (the same as used during calibration) allows correcting for stray light in the UV-B region of the spectrum.

In addtion, for each of these protocols, there are three different methods available for dealing with noise: \emph{original}, \emph{full}, and \emph{sun}. The three methods are interrelated, because the last two are based on the first one. Method \emph{sun} differs from \emph{full} only in that short wavelengths \betxbf{known} not to be present in sunlight at ground level are forced to zero. Method \emph{full} is the most suitable for measurements of artificial light sources. The main difference between methods \emph{original} and \emph{full} is that the second one uses adaptive smoothing and trimming to remove noise from low-signal regions of the spectrum, while the original method did not. Method \emph{original} implements an algorithm slightly modified from Lasse Ylianttila's original algorithm, while the other methods implement more substantial changes to the algorithm.

\subsection{Three different functions}

The \texttt{MayaCalc} package provides three different functions for applying calibrations: \texttt{process\_maya\_files}, \texttt{process\_maya\_raw\_ls}, and \texttt{process\_maya\_arrays}. The first and second ones use the last one internally, and they differ only on how the raw data is provided, either as file names to output files containing raw measurements obtained with Ocean Optics' SpectraView software or as R objects. Function \texttt{process\_maya\_raw\_ls} takes as argument an R list object with raw spectral data as returned by function \texttt{take\_readings} also defined in this package. We describe function \texttt{process\_maya\_arrays} only briefly as it is expected mainly to be used when the spectrometer data is acquired directly from within R.

Examples of the use of the first function are given below. All data, including integration times, is read from the files themselves. The calibration data used is automatically chosen based on the date when the raw data was measured, read from the files themselves. The \texttt{method} parameter together with what files are supplied as argument determine which method is used when applying the calibration. As a minimum two raw data files should be supplied, one for measurement readings and one for dark readings. This is usually enough when measuring output from LEDs or other sources with narrow emission spectra.

In addition the \texttt{method} parameter can be used to select among different smoothing and noise suppression algorithms. The function has additional parameters for manually tunning the smoothing and trimming used by the algorithms, but their use is rarely needed.

The function can be supplied a measuring time argument, to override the time in the files. The only case when this would be needed is when the measurements have been done using a computer with the clock set to a wrong date.

In the case of the second function the information about integration times, spectrometer serial number, calibration data index, etc.\ needs to be explicitly supplied through arguments, together with the whole set of raw data readings in a data.table object.

\subsection{Example raw data sets}

The package contains text files saved from the program \textsf{SpectraSuite} from \emph{Ocean Optics} running on a PC under Windows 7. Each file corresponds to one raw measurement. We here change the working directory to the folder containing the files to be used in the next several sections.

<<>>=
opts_knit$set(root.dir = system.file("extdata", package = "MayaCalc"))
@

\subsection{Comparing use of UV filter with no filter}

Here we show the effect of using a long-pass UV filter to corredt for stray light in measurements of an articifial UV light source. Further examples of using NR with sunlight are given in later sections, here we simply demonstarte how the protocol is automatically detected. The default method, \emph{original} is used.

\begin{framed}
\noindent
These data need to be replaced, as in this case the use of the filter makes things worse by introducing additional noise, and also there is unusual noise in the UV-A region.
\end{framed}

<<calib-example-filter0, eval=TRUE>>=
calib0.spct <- process_maya_files("inst/extdata/C1UV_5_9_00000.txt",
                                  "inst/extdata/C1UV_5_9_dark.txt")
is.source_spct(calib0.spct)
@


<<calib-example-filter1, eval=TRUE>>=
calib00.spct <- process_maya_files("C1UV_5_9_00000.txt",
                                   "C1UV_5_9_dark.txt",
                                   "C1UV_5_9_PC.txt")
is.source_spct(calib00.spct)
@

<<calib-example-filter2, eval=TRUE>>=
calib_filter.spct <-
  rbindspct(list(no=calib0.spct, yes=calib00.spct), idfactor = "filter")
@

<<calib-comparisom-fig0>>=
fig0 <- ggplot(data=calib_filter.spct, aes(x=w.length, y=s.e.irrad)) +
  geom_line() + facet_grid(~filter)
fig0_log <- fig0 + scale_y_log10(limits=c(1e-5, 1e0))
print(fig0)
print(fig0_log)
@

<<>>=
cat(comment(calib_filter.spct))
@

\subsection{Comparing processing methods}

Here we show the effect of using the different methods on a dark-corrected measurement of an articifial UV light source.

<<calib-example-1, eval=TRUE>>=
calib_spec1.spct <- process_maya_files("C1UV_5_9_00000.txt",
                                           "C1UV_5_9_dark.txt",
                                           "C1UV_5_9_PC.txt",
                                        method="original")
class_spct(calib_spec1.spct)
@

<<calib-example-2, eval=TRUE>>=
calib_spec2.spct <- process_maya_files("C1UV_5_9_00000.txt",
                                           "C1UV_5_9_dark.txt",
                                           "C1UV_5_9_PC.txt",
                                           method="full")
class_spct(calib_spec2.spct)
@

<<calib-example-3, eval=TRUE>>=
 calib_spec3.spct <- process_maya_files("C1UV_5_9_00000.txt",
                                           "C1UV_5_9_dark.txt",
                                           "C1UV_5_9_PC.txt",
                                           method="sun")
class_spct(calib_spec3.spct)
@

<<calib-example-4, eval=TRUE>>=
 calib_spec4.spct <- process_maya_files("C1UV_5_9_00000.txt",
                                           "C1UV_5_9_dark.txt",
                                           "C1UV_5_9_PC.txt",
                                           method="raw")
class_spct(calib_spec4.spct)
@

<<calib-example-5, eval=TRUE>>=
 calib_spec5.spct <- process_maya_files("C1UV_5_9_00000.txt",
                                           "C1UV_5_9_dark.txt",
                                           "C1UV_5_9_PC.txt",
                                           method="raw_sm")
class_spct(calib_spec5.spct)
@

<<calib-comparison, tidy=FALSE>>=
 calib_spec.spct <- rbindspct(list(original=calib_spec1.spct,
                                   full=calib_spec2.spct,
                                   sun=calib_spec3.spct),
                              idfactor = "method")

 raw_spec.spct <- rbindspct(list(raw = calib_spec4.spct,
                                 raw_sm = calib_spec5.spct),
                            idfactor = "method")
 @

<<calib-comparisom-fig1>>=
fig1 <- ggplot(data=calib_spec.spct, aes(x=w.length, y=s.e.irrad)) +
  geom_line() + facet_grid(~method)
fig1_log <- fig1 + scale_y_log10(limits=c(1e-5, 1e0))
print(fig1)
print(fig1_log)
@

<<raw-fig1a>>=
fig1a <- ggplot(data=raw_spec.spct, aes(x=w.length, y=cps)) +
  geom_line() + facet_grid(~method) +
  labs(y="Corrected raw counts (s-1)")
fig1a_log <- fig1a + scale_y_log10(limits=c(1, 2e5))
print(fig1a)
print(fig1a_log)
@

Here we show the effect of using the different methods on a stray-light-corrected measurement of a red LED.

<<LED436-example-1, eval=TRUE>>=
LED436_spec1.spct <- process_maya_files("BS436.txt",
                                       "BS436dark.txt")
@

<<LED436-example-2, eval=TRUE>>=
LED436_spec2.spct <- process_maya_files("BS436.txt",
                                       "BS436dark.txt",
                                       method="full")
@

<<LED436-example-3, eval=TRUE>>=
LED436_spec3.spct <- process_maya_files("BS436.txt",
                                       "BS436dark.txt",
                                       method="sun")
@

<<LED436-comparison, tidy=FALSE>>=
LED436_spectra.spct <-
  rbindspct(list(original = LED436_spec1.spct,
                 full     = LED436_spec2.spct,
                 sun      = LED436_spec3.spct),
            idfactor = "method")
@

<<LED436-comparisom-fig2>>=
fig2 <- ggplot(data=LED436_spectra.spct, aes(x=w.length, y=s.e.irrad)) +
  geom_line() + facet_grid(~method)
fig2_log <- fig2 + scale_y_log10(limits=c(1e-5, 1e0))
print(fig2)
print(fig2_log)
@

\texttt{source\_spct} and \texttt{cps\_spct} objects returned have a comment with data on the measurement.

<<comments>>=
cat(comment(LED436_spec1.spct))
@

\section{Bracketing (HDR) and stray-light reduction (NR)}

To exemplify the use of the available methods we use a set of six readings that allows us to compare the methods for the same light source, the mid-morning sun in May in Helsinki:   ``short" measurement reading, ``short" dark reading, ``short'' UV-filter reading, ``long" measurement reading, ``long" dark reading, ``long'' long-pass UV-filter reading.

Here we show the effect of using high-dynamic-range (HDR) on a dark-corrected and bracketed measurement of sunlight.

<<Sun-bracket-NR-example, eval=TRUE>>=
sun_HDR_NR_spec.spct <- process_maya_files("meas6n_short.txt",
                                       "dark6_short.txt",
                                       "pc6_long.txt",
                                       "meas6n_long.txt",
                                       "dark6_long.txt",
                                        method = "sun")

cat(comment(sun_HDR_NR_spec.spct))
@

<<Sun-bracket-example, eval=TRUE>>=
sun_HDR_spec.spct <- process_maya_files("meas6n_short.txt",
                                       "dark6_short.txt",
                                       NULL,
                                       "meas6n_long.txt",
                                       "dark6_long.txt",
                                        method = "sun")
cat(comment(sun_HDR_spec.spct))
@

<<Sun-short-NR-example, eval=TRUE>>=
sun_NR_spec.spct <- process_maya_files("meas6n_short.txt",
                                       "dark6_short.txt",
                                       "pc6_short.txt",
                                        method = "sun")

cat(comment(sun_NR_spec.spct))
@

<<Sun-short-example, eval=TRUE>>=
sun_spec.spct <- process_maya_files("meas6n_short.txt",
                                    "dark6_short.txt",
                                    method = "sun")

cat(comment(sun_spec.spct))
@

<<Sun-comparison, tidy=FALSE>>=
sun_spectra.spct <-
  rbindspct(list("HDR + NR" = sun_HDR_NR_spec.spct,
                 HDR = sun_NR_spec.spct,
                 NR = sun_HDR_spec.spct,
                 none = sun_spec.spct),
            idfactor = "method")
@

<<Sun-comparisom-fig3, fig.width=8, fig.height=4, out.width='.94\\textwidth'>>=
fig3 <- ggplot(data=sun_spectra.spct, aes(x=w.length, y=s.e.irrad)) +
  geom_line() + facet_grid(~method)
fig3_log <- fig3 + scale_y_log10(limits=c(1e-4, 1e0))
print(fig3)
print(fig3_log)
@

<<Sun-comparisom-fig4, fig.width=8, fig.height=4, out.width='.94\\textwidth'>>=
fig4 <- fig3 + xlim(290,400) + ylim(0,0.45)
fig4_log <- fig4 + scale_y_log10(limits=c(1e-4, 1e0))
print(fig4)
print(fig4_log)
@

Effective doses.

<<>>=
BSWFs <- list(GEN.G(), DNA.N(), PG(), CIE())
@

<<>>=
e_irrad(sun_HDR_NR_spec.spct, BSWFs)
e_irrad(sun_NR_spec.spct, BSWFs)
e_irrad(sun_HDR_spec.spct, BSWFs)
e_irrad(sun_spec.spct, BSWFs)
@

<<>>=
q_irrad(sun_HDR_NR_spec.spct, Plant_bands()) * 1e6
q_irrad(sun_NR_spec.spct, Plant_bands()) * 1e6
q_irrad(sun_HDR_spec.spct, Plant_bands()) * 1e6
q_irrad(sun_spec.spct, Plant_bands()) * 1e6
@

\section{Using \texttt{verbose} to obtain more detailed output}

<<Sun-bracket-NR-verbose-example, eval=TRUE, warning=TRUE>>=
sun_HDR_NR_spec_v.spct <- process_maya_files("meas6n_short.txt",
                                       "dark6_short.txt",
                                       "pc6_long.txt",
                                       "meas6n_long.txt",
                                       "dark6_long.txt",
                                        method = "sun",
                                        verbose = TRUE)
is.source_spct(sun_HDR_NR_spec_v.spct)
@

<<>>=
cat(comment(sun_HDR_NR_spec_v.spct))
@

<<verbose-output>>=
names(sun_HDR_NR_spec.spct)

names(sun_HDR_NR_spec_v.spct)
@

\section{Forcing the use of a different measurement date}

Giving the same date as in the file, to make sure that correct calibration is used.

<<Sun-bracket-NR-time-user-example1, eval=TRUE, warning=TRUE, tidy=FALSE>>=
sun_HDR_NR_spec_ut_real.spct <-
     process_maya_files("meas6n_short.txt", "dark6_short.txt",
                        "pc6_long.txt", "meas6n_long.txt",
                        "dark6_long.txt", method = "sun",
                         meas_time_user = as.POSIXct("May 31 11:20:56 2013",
                                                     format="%B %d %H:%M:%S %Y",
                                                     tz="EET"))

cat(comment(sun_HDR_NR_spec_ut_real.spct))
@

Giving a date one year after the real measurement date, to force use of a newer calibration, in this case totally invalid, as a different fibre was used.

<<Sun-bracket-NR-time-user-example2, eval=TRUE, warning=TRUE, tidy=FALSE>>=
sun_HDR_NR_spec_ut_fake.spct <-
     process_maya_files("meas6n_short.txt", "dark6_short.txt",
                        "pc6_long.txt", "meas6n_long.txt",
                        "dark6_long.txt", method = "sun",
                         meas_time_user = as.POSIXct("May 31 11:20:56 2014",
                                                     format="%B %d %H:%M:%S %Y",
                                                     tz="EET"))

cat(comment(sun_HDR_NR_spec_ut_fake.spct))
@

<<>>=
plot(sun_HDR_NR_spec_ut_real.spct) +
  labs(title="Using correct calibration")
plot(sun_HDR_NR_spec_ut_fake.spct) +
  labs(title="Forcing use of another calibration")
@

\section{Acquiring raw spectra}

The code chunk below is not evaluated, and uses defaults for the many parameters.

<<eval=FALSE>>=
start_session()
my.raw <- init_raw_spc()
my.raw <- set_params_raw_spc(my.raw)
my.raw <- take_readings(my.raw)
end_session()
@

\section{Applying calibration to spectra acquired with R}

As a spectrometer is not available while building the documentation,
we use data measured earlier with function \texttt{acq\_interactive}
and saved to a file. Bracketing used and automatic setting of
integartion time. These example data are included in the package.

\subsection{Measurement protocols}

In the chunks below, we apply calibrations and corrections to raw
spectral data measured following different protocols.


Only one measurement, with method automatically set to \texttt{"raw"}.

<<>>=
m.spct <- process_maya_raw_ls(m_raw)
plot(m.spct)
cat(comment(m.spct))
@

Light measurement, and dark measurement.

<<>>=
md.spct <- process_maya_raw_ls(md_raw)
plot(md.spct)
cat(comment(md.spct))
@

Light measurement, UV-filtered light measurement, dark measurement.

<<>>=
mfd.spct <- process_maya_raw_ls(mfd_raw)
plot(mfd.spct)
cat(comment(mfd.spct))
@

As above, but with two dark measurements, of which only
one is used in the current version.

<<>>=
dmfd.spct <- process_maya_raw_ls(dmfd_raw)
plot(dmfd.spct)
cat(comment(dmfd.spct))
@

<<>>=
no_HDR.spct <- process_maya_raw_ls(no_HDR_raw)
plot(no_HDR.spct)
cat(comment(no_HDR.spct))
@

<<>>=
clipped.spct <- process_maya_raw_ls(HDR_overx2_raw)
plot(clipped.spct)
cat(comment(clipped.spct))
@

<<>>=
HDR_2.spct <- process_maya_raw_ls(HDR_2_raw)
plot(HDR_2.spct)
cat(comment(HDR_2.spct))
@

<<>>=
HDR_3.spct <- process_maya_raw_ls(HDR_3_raw, which_in_HDR = NULL)
plot(HDR_3.spct)
cat(comment(HDR_3.spct))
@

<<>>=
HDR_3_1.spct <- process_maya_raw_ls(HDR_3_raw, which_in_HDR = 1)
plot(HDR_3_1.spct)
cat(comment(HDR_3_1.spct))
@

<<>>=
HDR_3_1.spct <- process_maya_raw_ls(HDR_3_raw, which_in_HDR = 2)
plot(HDR_3_1.spct)
cat(comment(HDR_3_1.spct))
@

<<>>=
HDR_3_1.spct <- process_maya_raw_ls(HDR_3_raw, which_in_HDR = 3)
plot(HDR_3_1.spct)
cat(comment(HDR_3_1.spct))
@

<<>>=
HDR_3_12.spct <- process_maya_raw_ls(HDR_3_raw, which_in_HDR = c(1,2))
plot(HDR_3_12.spct)
cat(comment(HDR_3_12.spct))
@

<<>>=
HDR_3_13.spct <- process_maya_raw_ls(HDR_3_raw, which_in_HDR = c(1,3))
plot(HDR_3_13.spct)
cat(comment(HDR_3_13.spct))
@

<<>>=
HDR_3.spct <- process_maya_raw_ls(HDR_3_raw, which_in_HDR = NULL, method = "raw")
plot(HDR_3.spct)
cat(comment(HDR_3.spct))
@

<<>>=
HDR_3.spct <- process_maya_raw_ls(HDR_3_raw, which_in_HDR = c(1,2), method = "raw")
plot(HDR_3.spct)
cat(comment(HDR_3.spct))
@

<<>>=
HDR_3_1.spct <- process_maya_raw_ls(HDR_3_raw, which_in_HDR = 1, method = "raw")
plot(HDR_3_1.spct)
cat(comment(HDR_3_1.spct))
@

<<>>=
HDR_3_1.spct <- process_maya_raw_ls(HDR_3_raw, which_in_HDR = 2, method = "raw")
plot(HDR_3_1.spct)
cat(comment(HDR_3_1.spct))
@

<<>>=
HDR_3_1.spct <- process_maya_raw_ls(HDR_3_raw, which_in_HDR = 3, method = "raw")
plot(HDR_3_1.spct)
cat(comment(HDR_3_1.spct))
@

\subsection{Processing methods}

<<>>=
mfd_rw.spct <- process_maya_raw_ls(mfd_raw, method = "raw")
plot(mfd_rw.spct)
cat(comment(mfd_rw.spct))
@

<<>>=
mfd_rws.spct <- process_maya_raw_ls(mfd_raw, method = "raw_sm")
plot(mfd_rws.spct)
@

<<>>=
mfd_orig.spct <- process_maya_raw_ls(mfd_raw, method = "original")
plot(mfd_orig.spct)
@

<<>>=
mfd_sun.spct <- process_maya_raw_ls(mfd_raw, method = "sun")
plot(mfd_sun.spct)
@

<<>>=
mfd_full.spct <- process_maya_raw_ls(mfd_raw, method = "full")
plot(mfd_full.spct)
@

Use only the ``short`` measurement from an HDR measurement.

<<>>=
mfd_no_HDR.spct <- process_maya_raw_ls(mfd_raw, which_in_HDR = 1)
plot(mfd_full.spct)
cat(comment(mfd_no_HDR.spct))
@



\section{Acquiring calibrated spectra}

A function for interactive acquisition of calibrated plus
raw spectral data.

<<eval=FALSE>>=
acquire_interactive()
@

No HDR.

<<eval=FALSE>>=
acquire_interactive(HDR.mul = 1)
@

Increase "automatically set" integration time by 25\%.

<<eval=FALSE>>=
acquire_interactive(HDR.mul = 1.25)
@

Three different integration times.

<<eval=FALSE>>=
acquire_interactive(HDR.mul = c(1,5,10))
@

Minimum total measuring time 0.5 seconds.

<<eval=FALSE>>=
acquire_interactive(min.tot.time = 0.5)
@

Non default method.

<<eval=FALSE>>=
acquire_interactive(method = "full")
@

\end{document}
