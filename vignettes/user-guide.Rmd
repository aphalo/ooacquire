---
title: "`ooacquire` `r packageVersion('ooacquire')`<br>User Guide"
author: "Pedro J. Aphalo"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{User Guide}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Introduction

In this package we define higher-level functions using packages 'rOmniDriver' and the 'r4photobiology' suite as bases. 
These functions conform a sort of "grammar for spectral data acquisition". We
provide a separate function for each conceptual step in the process leading
from raw counts to final spectral data---e.g. spectral irradiance. 

The initial steps are opening a connection to an instrument and retrieving a 
descriptor including model type, optical configuration and possibly calibration data from its non-volatile memory. These first steps in most cases are needed only at the start the R session where data will be acquired. 

The steps for the acquisition of one raw spectrum are to 1) define the settings to be used, 2) optionally adjust or tune some of these settings automatically, 3) acquire the spectrum, 4) convert the raw counts into linearised counts per second.

In most cases we need acquire more than one raw spectrum, frequently following a certain protocol. There are two possibilities: a) they are conceptually a single observation, such as multiple scans to be averaged to reduce noise or acquired with different integration times (bracketing) and to be merged to increase the dynamic range, and b) sets of spectra in which each spectrum represents a different observation, such as a 'measurement' spectrum and a 'dark' spectrum to be used to correct it.  The distinction may be not that easy to grasp, but in case a) we are measuring a single thing, what we are measuring remains unchanged for all spectra acquired in a set---e.e. we are measuring repeatedly, possibly changing the instrument settings. In case b), although the different spectra may contribute to a single processed spectrum, they are based on measuring a different thing, say a light source and a corresponding dark reading.

In case a) all the acquired raw spectra are stored as columns in the same `raw_spct` object, while in case b) the different conceptual spectra are each stored in a separate `raw_spct` object, member of a `raw_mspct` collection of spectra object. As a) and b) are usually combined, this approach allows and easy distinction of the two situations, and greatly simplifies the coding of later data processing steps.

Following the approach of the 'r4photobiology' suite, we store all available
metadata as attributes to the same objects where the acquired spectral data themselves are stored. The stored metadata includes a descriptor of the instrument and the instruments settings used, in addition to metadata that is held in spectral objects of classes defined in package 'photobiology', such as time, location, and label for the measured data. Furthermore, metadata is added at each step, allowing the tracing of the origin and processing of the data. This allows the functions to detect mistakes like an user attempting to linearise raw-counts data that have been already linearised.

In all cases a wavelength calibration is used to map the pixels to wavelengths. Wavelength calibration can be that retrieved from the instruments' non-volatile memory or supplied directly by to user. Different further steps are needed depending on the quantity measured. In the case of 
irradiance, a calibration needs to be applied to the raw spectral data. Usually
calibration data is also stored in the non-volatile memory of the spectrometer, but
in some cases it is convenient to apply special algorithms or calibration data 
that cannot be retrieved from the instrument itself. Functions for both the normal and special 
cases are also included in the package. Here it is important to remember that a calibration will be valid only if the raw spectral data processing steps are exactly the same for the calibration spectral data and the measured data. **This in practice means that calibrations supplied by instrument manufacturers will almost never be usable if you process the measured data with this pacakge. You will need the reference lamp spectrum and the raw detector-counts data for the calibration event, to be able to calculte valid calibration coefficients for the exact same data-processing protocol you adopt for your actual measurements.** On the other hand, this also means that the functions in the present package, as each of them fulfils a simple and well defined step of data processing, are ideal for _in silico_ testing of alternative data processing approaches and measuring protocols. 

## Functions

| function name | role |
| ---------|----------------------------------------------------------|
| `start_session()` | search for connected instruments and obtain a handle to the driver |
| `end_session()` | close all connections and release handle |
| `list_instruments()`| list all connected instruments |
| `get_oo_descriptor()` | get a descriptor for one of the possibly several connected instruments |
| `set_descriptor_wl()` | replace the wavelength values |
| `set_descriptor_bad_pixs()` | replace the indexes to bad array detector pixels |
| `set_descriptor_nl()` | replace the function used to correct for array non-linearity |
| `set_descriptor_calib_mult()` | replace the vector of irradiance calibration multipliers |
| `set_descriptor_integ_time()` | replace the vector defining the range of valid integration times |
| `get_oo_settings()` | query the instrument to obtain its current settings |
| `acq_settings()` | build a list of setting values |
| `tune_acq_settings()` | tune the integration time and number of scans to the current radiation conditions |
| `acq_raw_spct()` | take one measurement (data point) |
| `trim_counts()` | replace values from saturated array pixels with NAs |
| `acq_raw_mspct()` | take a sequence of spectral measurement (several data points) |
| `linearize_counts()` | linearize the raw counts |
| `skip_bad_pixs()` | replace bad pixels with interpolated raw counts |
| `ref_correction()`| subtract a reference (e.g. dark signal) from a measured spectrum |
| `photobiology::fshift()`| can be used to subtract a region of the same scan as an internal "dark" reference |
| `raw2cps()` | methods to convert raw counts into counts per second |
| ---     | the method specialization for `raw_spct` returns a `cps_spct` object |
| `merge_cps()` | method to do HDR merge of bracketed scans |
| `cps2irrad()` | methods to convert counts per second into spectral irradiance |
| `cps2Tfr()` | methods to convert counts per second into transmittance |
| `cps2Rfr()` | methods to convert counts per second into reflectance |
| `uvb_corrections()` | apply corrections for reducing the impact of stray light on UVB measurements |
| `slit_function_correction()` | apply a correction for the'long tails' of the slit function |
| `filter_correctio()` | apply a correction for stray light based on the use of UV-cut-off filter |

## Workflow

The workflow consists in several steps. First all one needs to start a new connection to the driver by means of `start_session()` and disconnect at the end of the measuring session with `end_session()`. To learn which instruments are connected and which numerical index pints to each one uses `list_instruments()`. The indexes start at zero, so if there is only one instrument connected one can rely on its index being 0. The same applies to channels, for multichannel instruments.

Once we know which instrument we want to address and its index, we must create an instrument descriptor with function `get_oo_descriptor()`. From this point onwards we will use this _descriptor_ to address the instrument. The descriptor contains information about the instrument obtained initially by querying it. Instruments may have some pieces of information unavailable (e.g. not stored in there non-volatile memory), or the user may want to override the available information with that from a more recent or better calibration. `set_descriptor_nl()`, `set_descriptor_wl()`, `set_descriptor_bad_pixs()` and `set_descripto_integ_time()` can be used to set or override the function used for correcting for the non-linearity of the sensors, the wavelength values corresponding to each pixel, a vector of indexes (starting at one) corresponding to bad pixels in the array (pixel known to return bad data) and the range of integration times in ms that are valid input for the instrument. __It is always good to check against the specifications of the instrument whether the values stored in its 

As there are several settings needed for the acquisition of a spectrum, we will store sets of settings into objects that can reuse and modify. To create these objects we use function `acq_settings()`. The _settings_ include both actual parameters that need to be set in the instrument by sending commands and parameters that our software may use to calculate suitable values for such settings. This function is quite flexible and allows the use of bracketing. In other words a single observation can consist in more than one data acquisition, each of these using different setting, with the aim of merging them into a single spectrum.

Some settings need to be adjusted according to the current irradiance level so as to make full use of the dynamic range of the instrument. For this we use function `tune_acq_settings()`, which updates the settings stored in a list as created by `acq_settings()` or as returned by a previous call to `tune_acq_settings()`.

Function `get_oo_settings()` can be used to query the instrument for the settings currently in use. 

To acquire spectral data we can use one of two functions, `acq_raw_spct()` to acquire a single spectrum, or `acq_raw_mspct()` to acquire a collection of spectra according to a user supplied protocol. In cases when we use HDR (bracketing) or _overexpose_ some part of the spectrum the first data-processing step is to replace the data from the saturated pixels with `NA`'s using function `trim_counts()`---as the settings used in the acquisition and descriptor of the instrument are stored in the spectral object, this function needs only to be supplied a `raw_spct` object, unless the user wants to discard more pixels. As pixels neighbouring _overexposed_ pixels are disturbed by the charge _overflowing_ from the saturated wells, these pixels need also to be set as NAs by means of function `bleed_nas`. If the instrument array contains bad pixels, it is best to replace the data produced by them at this early stage. Function `skip_bad_pixs()` is useful here and it replaces the bad data with the average of the readings from the neighbouring pixels. The third step after data acquisition, unless the linearisation is done by the instrument, is to linearize the acquired _valid_ raw counts by means of method `linearize_counts()`. The non-linearity of the detector is related to how "full" are its electron wells, irrespective of whether the electrons originate from measured photons or any other source, consequently the linearisation function should be applied to raw detector counts at this point. 

CCD arrays, especially if not cooled, have a significant dark signal. The best approach to remove this _background_ signal is to measure it---to take a spectral reading with the array not exposed to light. This _dark spectrum_ is them subtracted from the one measured in the light. An alternative, with advantages and disadvantages, is to use the signal from pixels corresponding to wavelengths **known** _a priori_ to be absent in the light source being measured. This calculation is done with the **linearized** raw counts by means of method `photobiology::fshift()` with a pair of suitable wavelength values for `range`. In the case of measuring transmittance (and absorbance) and reflectance we need to also measure a _clear_ and _white_ reference respectively.

The raw counts after linearisation followed by subtraction of the dark signal are still expressed in number of counts per integration period. As the duration of the integration time is variable, we need to re-express the raw counts as counts-per-second (_cps_). Once more, the integration time used for the acquisition is stored in the `cps_spct` object and the conversion can be done by method `raw2cps()` with just this object as input. The values returned, expressed as counts per second, are linearly proportional to the rate at which photons imping each detector pixel. Be aware that as detector quantum yield depends on wavelength, a different multiplier is needed for each pixel to be able to convert the counts-per-second data to units of photons-per-unit-time. 

If bracketing for HDR has been used during acquisition, at this point, the values of the _cps_ for each of the bracketed spectra are expressed on the same scale. This means that they can simply be spliced together. The simplest approach possible, used by method `merge_cps()` is to replace the clipped data from saturated pixels (and possibly their neighbours) in the longer integration with data from the same pixels obtained with shorter integration. As we used `trim_counts()` and `bleed_nas` on the raw counts, those saturated pixels have already been replaced with `NA`'s making the operation easy to implement.

After the preceding steps, if the _cps_ or merged _cps_ values are from an irradiance measurement the spectral data are now ready to be multiplied by the calibration constants corresponding to each individual pixel. If the values are to be used for calculation of transmittance or reflectance, all what is left to do is simple arithmetic.

## Additional corrections

### Slit function correction


## Irradiance calibration

### Calculating calibration constants

### Applying calibration constants

## What's next

You can compose from these simple functions different measurement protocols and data processing sequences. This is the reason why they have been designed as a set of small functions, each one doing a single operation.

Please see the example scripts installed with the package.

